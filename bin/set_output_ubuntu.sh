#!/usr/bin/env bash
# Output from `set > thisfile.txt`
# Set is HUGE, lots of unused vars and other stuff.

Assoc=([brc]="/home/carlc/.bashrc" [pro]="/home/carlc/.profile" )
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:dotglob:expand_aliases:extglob:extquote:force_fignore:globasciiranges:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="10")
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="0" [2]="17" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='5.0.17(1)-release'
BROWSER=wslview
COLUMNS=144
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
CONDA_DEFAULT_ENV=sci
CONDA_EXE=/home/carlc/miniconda3/bin/conda
CONDA_PREFIX=/home/carlc/miniconda3/envs/sci
CONDA_PREFIX_1=/home/carlc/miniconda3
CONDA_PROMPT_MODIFIER='(sci) '
CONDA_PYTHON_EXE=/home/carlc/miniconda3/bin/python
CONDA_SHLVL=2
DEFAULT_XDG_CONFIG_DIRS=/etc/xdg
DEFAULT_XDG_DATA_DIRS=/usr/local/share/:/usr/share/
DENO_INSTALL=/home/carlc/.deno
DIRSTACK=()
DISPLAY=172.29.192.1:0.0
DOTFILES=/home/carlc/.dotfiles/ubuntu
DOTNET_CLI_TELEMETRY_OPTOUT=1
DWWW_BROWSER=lynx
EDITOR=/usr/bin/vim
EUID=1000
GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'
GEM_HOME=/home/carlc/gems
GRADLE_HOME=/home/carlc/.sdkman/candidates/gradle/current
GROOVY_HOME=/home/carlc/.sdkman/candidates/groovy/current
GROUPS=()
GSETTINGS_SCHEMA_DIR=/home/carlc/miniconda3/envs/sci/share/glib-2.0/schemas
GSETTINGS_SCHEMA_DIR_CONDA_BACKUP=
HISTCONTROL=ignoreboth
HISTFILE=/home/carlc/.bash_history
HISTFILESIZE=2000
HISTSIZE=1500
HOME=/home/carlc
HOSTNAME=GWTN141-10
HOSTTYPE=x86_64
IFS=$' \t\n'
INITVIM=/home/carlc/.config/nvim/init.vim
INITVIM_GIT=/home/carlc/.dotfiles/ubuntu/init.vim
JAVA_HOME=/home/carlc/.sdkman/candidates/java/current
KI_HOME=/home/carlc/.sdkman/candidates/ki/current
KOTLIN_HOME=/home/carlc/.sdkman/candidates/kotlin/current
KSCRIPT_HOME=/home/carlc/.sdkman/candidates/kscript/current
LANG=C.UTF-8
LEININGEN_HOME=/home/carlc/.sdkman/candidates/leiningen/current
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=35
LOGNAME=carlc
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MAVEN_HOME=/home/carlc/.sdkman/candidates/maven/current
MOTD_SHOWN=update-motd
MY_BASH_CONFIG=([0]="/home/carlc/.bashrc" [1]="/home/carlc/.profile" [2]="/home/carlc/.shell_functions" [3]="/home/carlc/.bash_aliases" [4]="/home/carlc/.shell_aliases")
NAME=GWTN141-10
OLDPWD=/home/carlc/.dotfiles
ONEDRIVE=/mnt/c/Users/Carl/OneDrive
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
OneDrive=/mnt/c/Users/Carl/OneDrive
PAGER=/usr/bin/less
PATH='/home/carlc/.local/bin:/home/carlc/bin:/home/carlc/.sdkman/candidates/springboot/current/bin:/home/carlc/.sdkman/candidates/scala/current/bin:/home/carlc/.sdkman/candidates/sbt/current/bin:/home/carlc/.sdkman/candidates/maven/current/bin:/home/carlc/.sdkman/candidates/leiningen/current/bin:/home/carlc/.sdkman/candidates/kscript/current/bin:/home/carlc/.sdkman/candidates/kotlin/current/bin:/home/carlc/.sdkman/candidates/ki/current/bin:/home/carlc/.sdkman/candidates/java/current/bin:/home/carlc/.sdkman/candidates/groovy/current/bin:/home/carlc/.sdkman/candidates/gradle/current/bin:/home/carlc/.rbenv/shims:/home/carlc/.rbenv/bin:/home/carlc/.cargo/bin:/home/carlc/.cargo/bin:/home/carlc/.deno/bin:/home/carlc/miniconda3/envs/sci/bin:/home/carlc/miniconda3/condabin:/home/carlc/.local/bin:/home/carlc/gems/bin:/home/carlc/.npm-packages/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/lib/wsl/lib:/mnt/c/Users/Carl/AppData/Roaming/Python/Python39/Scripts:/mnt/c/Users/Carl/AppData/Roaming/npm:/mnt/c/Users/Carl/.cargo/bin:/mnt/c/Program Files/Go/bin:/mnt/c/Program Files/dotnet:/mnt/c/Users/Carl/AppData/Roaming/npm:/mnt/c/Users/Carl/gitstuff/scripts-pwsh/bin:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv/Library/mingw-w64/bin:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv/Library/usr/bin:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv/Library/bin:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv/Scripts:/mnt/c/Users/Carl/miniconda3/envs/pyscriptenv/bin:/mnt/c/Users/Carl/miniconda3/condabin:/mnt/c/Program Files/PowerShell/7:/mnt/c/ActiveTcl/bin:/mnt/c/windows/system32:/mnt/c/windows:/mnt/c/windows/System32/Wbem:/mnt/c/windows/System32/WindowsPowerShell/v1.0:/mnt/c/windows/System32/OpenSSH:/mnt/c/ProgramData/chocolatey/bin:/mnt/c/Program Files/dotnet:/mnt/c/Program Files/Microsoft SQL Server/130/Tools/Binn:/mnt/c/Program Files/Microsoft SQL Server/Client SDK/ODBC/170/Tools/Binn:/mnt/c/HashiCorp/Vagrant/bin:/mnt/c/Program Files/nodejs:/mnt/c/Program Files/Go/bin:/mnt/c/Program Files/Docker/Docker/resources/bin:/mnt/c/ProgramData/DockerDesktop/version-bin:/mnt/c/Program Files/Eclipse Foundation/jdk-8.0.302.8-hotspot/bin:/mnt/c/Program Files (x86)/dotnet:/mnt/c/Program Files/PowerShell/7:/mnt/c/Users/Carl/scoop/apps/graalvm-jdk11/current/bin:/mnt/c/Users/Carl/scoop/apps/gpg/current/bin:/mnt/c/Ruby31-x64/bin:/mnt/c/Users/Carl/.nimble/bin:/mnt/c/Users/Carl/scoop/apps/gcc/current/bin:/mnt/c/Users/Carl/scoop/apps/maven/current/bin:/mnt/c/Users/Carl/scoop/apps/ant/current/bin:/mnt/c/Users/Carl/scoop/apps/mongodb-database-tools/current/bin:/mnt/c/Users/Carl/AppData/Roaming/npm:/mnt/c/Users/Carl/.deno/bin:/mnt/c/Users/Carl/.cargo/bin:/mnt/c/Users/Carl/go/bin:/mnt/c/Users/Carl/scoop/shims:/mnt/c/Users/Carl/AppData/Local/Microsoft/WindowsApps:/mnt/c/Users/Carl/AppData/Local/GitHubDesktop/bin:/mnt/c/Users/Carl/AppData/Local/Programs/Microsoft VS Code/bin:/mnt/c/Users/Carl/.dotnet/tools:/mnt/c/Program Files/Meson:/mnt/c/Users/Carl/go/bin:/mnt/c/Users/Carl/.dotnet/tools:/snap/bin:/home/carlc/.dotnet/tools:/home/carlc/.fzf/bin'
PIPESTATUS=([0]="0")
PPID=4669
PS1='(sci) \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
PS2='> '
PS4='+ '
PWD=/home/carlc/.dotfiles/bin
RBENV_SHELL=bash
SBT_HOME=/home/carlc/.sdkman/candidates/sbt/current
SCALA_HOME=/home/carlc/.sdkman/candidates/scala/current
SDKMAN_CANDIDATES=([0]="activemq" [1]="ant" [2]="asciidoctorj" [3]="ballerina" [4]="bpipe" [5]="btrace" [6]="concurnas" [7]="connor" [8]="cuba" [9]="cxf" [10]="doctoolchain" [11]="flink" [12]="gaiden" [13]="gradle" [14]="gradleprofiler" [15]="grails" [16]="groovy" [17]="groovyserv" [18]="hadoop" [19]="http4k" [20]="infrastructor" [21]="java" [22]="jbake" [23]="jbang" [24]="jmc" [25]="jmeter" [26]="joern" [27]="jreleaser" [28]="karaf" [29]="kcctl" [30]="ki" [31]="kobweb" [32]="kotlin" [33]="kscript" [34]="layrry" [35]="leiningen" [36]="maven" [37]="mcs" [38]="micronaut" [39]="mulefd" [40]="mvnd" [41]="mybatis" [42]="neo4jmigrations" [43]="pierrot" [44]="pomchecker" [45]="quarkus" [46]="sbt" [47]="scala" [48]="scalacli" [49]="schemacrawler" [50]="spark" [51]="springboot" [52]="sshoogr" [53]="taxi" [54]="test" [55]="tomcat" [56]="vertx" [57]="visualvm" [58]="webtau" [59]="znai")
SDKMAN_CANDIDATES_API=https://api.sdkman.io/2
SDKMAN_CANDIDATES_CACHE=/home/carlc/.sdkman/var/candidates
SDKMAN_CANDIDATES_CSV=activemq,ant,asciidoctorj,ballerina,bpipe,btrace,concurnas,connor,cuba,cxf,doctoolchain,flink,gaiden,gradle,gradleprofiler,grails,groovy,groovyserv,hadoop,http4k,infrastructor,java,jbake,jbang,jmc,jmeter,joern,jreleaser,karaf,kcctl,ki,kobweb,kotlin,kscript,layrry,leiningen,maven,mcs,micronaut,mulefd,mvnd,mybatis,neo4jmigrations,pierrot,pomchecker,quarkus,sbt,scala,scalacli,schemacrawler,spark,springboot,sshoogr,taxi,test,tomcat,vertx,visualvm,webtau,znai
SDKMAN_CANDIDATES_DIR=/home/carlc/.sdkman/candidates
SDKMAN_DIR=/home/carlc/.sdkman
SDKMAN_KERNEL=Linux
SDKMAN_PLATFORM=linuxx64
SDKMAN_VERSION=5.14.3
SHELL=bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SHOW=--show-only
SPRINGBOOT_HOME=/home/carlc/.sdkman/candidates/springboot/current
TERM=xterm-256color
UBULIB=/home/carlc/.dotfiles/ubuntu/lib
UBUNTU_DOTFILES=/home/carlc/.dotfiles/ubuntu
UID=1000
USER=carlc
WSLENV=WT_SESSION::WT_PROFILE_ID
WSL_DISTRO_NAME=Ubuntu-20.04
WSL_INTEROP=/run/WSL/4669_interop
WT_PROFILE_ID='{574e775e-4f2a-5b96-ac1e-a2962a402336}'
WT_SESSION=171de749-89fa-4162-9e7c-15dc6e4a38b2
XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop
_=--color=auto
_CE_CONDA=
_CE_M=
__cargo_commands=$'b\nbench\nbuild\nc\ncheck\nclean\nclippy\nclippy.exe\nconfig\nd\ndoc\nfetch\nfix\nfmt\nfmt.exe\ngenerate-lockfile\ngit-checkout\ninit\ninstall\nlocate-project\nlogin\nlogout\nmetadata\nmiri\nmiri.exe\nnew\nowner\npackage\npkgid\npublish\nr\nread-manifest\nreport\nrun\nrustc\nrustdoc\nsearch\nt\ntest\ntree\nuninstall\nupdate\nvendor\nverify-project\nversion\nyank'
__fzf_nospace_commands=' cd  pushd '
__git_printf_supports_v=yes
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_fzf_completion_loader=1
_fzf_orig_completion_awk='complete -F %s awk #_longopt'
_fzf_orig_completion_cat='complete -F %s cat #_longopt'
_fzf_orig_completion_cd='complete -o nospace -F %s cd #_cd'
_fzf_orig_completion_cp='complete -F %s cp #_longopt'
_fzf_orig_completion_diff='complete -F %s diff #_longopt'
_fzf_orig_completion_du='complete -F %s du #_longopt'
_fzf_orig_completion_ftp='complete -F %s ftp #_known_hosts'
_fzf_orig_completion_grep='complete -F %s grep #_longopt'
_fzf_orig_completion_head='complete -F %s head #_longopt'
_fzf_orig_completion_ld='complete -F %s ld #_longopt'
_fzf_orig_completion_less='complete -F %s less #_longopt'
_fzf_orig_completion_ln='complete -F %s ln #_longopt'
_fzf_orig_completion_ls='complete -F %s ls #_longopt'
_fzf_orig_completion_mv='complete -F %s mv #_longopt'
_fzf_orig_completion_pushd='complete -o nospace -F %s pushd #_cd'
_fzf_orig_completion_rm='complete -F %s rm #_longopt'
_fzf_orig_completion_rmdir='complete -F %s rmdir #_longopt'
_fzf_orig_completion_sed='complete -F %s sed #_longopt'
_fzf_orig_completion_sort='complete -F %s sort #_longopt'
_fzf_orig_completion_tail='complete -F %s tail #_longopt'
_fzf_orig_completion_tee='complete -F %s tee #_longopt'
_fzf_orig_completion_telnet='complete -F %s telnet #_known_hosts'
_fzf_orig_completion_uniq='complete -F %s uniq #_longopt'
_fzf_orig_completion_wc='complete -F %s wc #_longopt'
_xspecs=([lokalize]="!*.po" [acroread]="!*.[pf]df" [lbzcat]="!*.?(t)bz?(2)" [mpg321]="!*.mp3" [bzcat]="!*.?(t)bz?(2)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [unlzma]="!*.@(tlz|lzma)" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [lbunzip2]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvitype]="!*.dvi" [lobase]="!*.odb" [rpm2cpio]="!*.[rs]pm" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [epdfview]="!*.pdf" [dvips]="!*.dvi" [pdfunite]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf]="!*.@(?(e)ps|pdf)" [gpdf]="!*.[pf]df" [lilypond]="!*.ly" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [znew]="*.Z" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [pbzcat]="!*.?(t)bz?(2)" [poedit]="!*.po" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [dvipdfm]="!*.dvi" [kbabel]="!*.po" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [bzme]="!*.@(zip|z|gz|tgz)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [dviselect]="!*.dvi" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [mpg123]="!*.mp3" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [lzegrep]="!*.@(tlz|lzma)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [lzfgrep]="!*.@(tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzless]="!*.@(tlz|lzma)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.@(pdf|fdf)?(.@(gz|GZ|bz2|BZ2|Z))" [lomath]="!*.@(sxm|smf|mml|odf)" [lzcat]="!*.@(tlz|lzma)" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [pbunzip2]="!*.?(t)bz?(2)" [oobase]="!*.odb" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [gtranslator]="!*.po" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [zipinfo]="!*.@(zip|[egjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [unzip]="!*.@(zip|[egjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lrunzip]="!*.lrz" [lzgrep]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [oomath]="!*.@(sxm|smf|mml|odf)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [makeinfo]="!*.texi*" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lzmore]="!*.@(tlz|lzma)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdf]="!*.dvi" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" )
bash_shell=true
bashdoc=/usr/share/doc/bash
cygwin=false
darwin=false
freebsd=false
i=/home/carlc/.bash.d/rustup.bash
myCommands=([0]="pwshInvoke" [1]="groffman" [2]="pygcat" [3]="whichless" [4]=" " [5]="whichfile" [6]="hexConvert" [7]="whichl" [8]="gitaddandcommit" [9]="readmeDir" [10]=" " [11]="chromaless" [12]="chless" [13]="catimg" [14]="nodeprocessconf" [15]="nvimconfig" [16]=" " [17]="zhelpfix (zsh only)" [18]="list_trash" [19]="empty_trash" [20]="pyhelp" [21]=" " [22]="ghrestapi" [23]="duks" [24]="sinfo")
sdkman_auto_answer=false
sdkman_auto_complete=true
sdkman_auto_env=false
sdkman_auto_update=true
sdkman_beta_channel=false
sdkman_checksum_enable=true
sdkman_colour_enable=true
sdkman_curl_connect_timeout=7
sdkman_curl_continue=true
sdkman_curl_max_time=10
sdkman_curl_retry=0
sdkman_curl_retry_max_time=60
sdkman_debug_mode=false
sdkman_insecure_ssl=false
sdkman_rosetta2_compatible=true
sdkman_selfupdate_feature=true
snap_bin_path=/snap/bin
snap_xdg_path=/var/lib/snapd/desktop
solaris=false
usrdocs=/usr/share/doc
winhome=/mnt/c/Users/Carl
zsh_shell=false
___sdkman_check_candidates_cache () 
{ 
    local candidates_cache="$1";
    if [[ -f "$candidates_cache" && -n "$(< "$candidates_cache")" && -n "$(find "$candidates_cache" -mmin +$((24 * 60 * 30)))" ]]; then
        __sdkman_echo_yellow 'We periodically need to update the local cache. Please run:';
        echo '';
        __sdkman_echo_no_colour '  $ sdk update';
        echo '';
        return 0;
    else
        if [[ -f "$candidates_cache" && -z "$(< "$candidates_cache")" ]]; then
            __sdkman_echo_red 'WARNING: Cache is corrupt. SDKMAN cannot be used until updated.';
            echo '';
            __sdkman_echo_no_colour '  $ sdk update';
            echo '';
            return 1;
        else
            __sdkman_echo_debug "No update at this time. Using existing cache: $SDKMAN_CANDIDATES_CSV";
            return 0;
        fi;
    fi
}
___sdkman_check_version_cache () 
{ 
    local version_url;
    local version_file="${SDKMAN_DIR}/var/version";
    if [[ "$sdkman_beta_channel" != "true" && -f "$version_file" && -z "$(find "$version_file" -mmin +$((60 * 24)))" ]]; then
        __sdkman_echo_debug "Not refreshing version cache now...";
        SDKMAN_REMOTE_VERSION=$(cat "$version_file");
    else
        __sdkman_echo_debug "Version cache needs updating...";
        if [[ "$sdkman_beta_channel" == "true" ]]; then
            __sdkman_echo_debug "Refreshing version cache with BETA version.";
            version_url="${SDKMAN_CANDIDATES_API}/broker/download/sdkman/version/beta";
        else
            __sdkman_echo_debug "Refreshing version cache with STABLE version.";
            version_url="${SDKMAN_CANDIDATES_API}/broker/download/sdkman/version/stable";
        fi;
        SDKMAN_REMOTE_VERSION=$(__sdkman_secure_curl_with_timeouts "$version_url");
        if [[ -z "$SDKMAN_REMOTE_VERSION" || -n "$(echo "$SDKMAN_REMOTE_VERSION" | tr '[:upper:]' '[:lower:]' | grep 'html')" ]]; then
            __sdkman_echo_debug "Version information corrupt or empty! Ignoring: $SDKMAN_REMOTE_VERSION";
            SDKMAN_REMOTE_VERSION="$SDKMAN_VERSION";
        else
            __sdkman_echo_debug "Overwriting version cache with: $SDKMAN_REMOTE_VERSION";
            echo "${SDKMAN_REMOTE_VERSION}" | tee "$version_file" > /dev/null;
        fi;
    fi
}
__add_sys_prefix_to_path () 
{ 
    if [ -n "${_CE_CONDA}" ] && [ -n "${WINDIR+x}" ]; then
        SYSP=$(\dirname "${CONDA_EXE}");
    else
        SYSP=$(\dirname "${CONDA_EXE}");
        SYSP=$(\dirname "${SYSP}");
    fi;
    if [ -n "${WINDIR+x}" ]; then
        PATH="${SYSP}/bin:${PATH}";
        PATH="${SYSP}/Scripts:${PATH}";
        PATH="${SYSP}/Library/bin:${PATH}";
        PATH="${SYSP}/Library/usr/bin:${PATH}";
        PATH="${SYSP}/Library/mingw-w64/bin:${PATH}";
        PATH="${SYSP}:${PATH}";
    else
        PATH="${SYSP}/bin:${PATH}";
    fi;
    \export PATH
}
__conda_activate () 
{ 
    if [ -n "${CONDA_PS1_BACKUP:+x}" ]; then
        PS1="$CONDA_PS1_BACKUP";
        \unset CONDA_PS1_BACKUP;
    fi;
    \local ask_conda;
    ask_conda="$(PS1="${PS1:-}" __conda_exe shell.posix "$@")" || \return;
    \eval "$ask_conda";
    __conda_hashr
}
__conda_exe () 
{ 
    ( __add_sys_prefix_to_path;
    "$CONDA_EXE" $_CE_M $_CE_CONDA "$@" )
}
__conda_hashr () 
{ 
    if [ -n "${ZSH_VERSION:+x}" ]; then
        \rehash;
    else
        if [ -n "${POSH_VERSION:+x}" ]; then
            :;
        else
            \hash -r;
        fi;
    fi
}
__conda_reactivate () 
{ 
    \local ask_conda;
    ask_conda="$(PS1="${PS1:-}" __conda_exe shell.posix reactivate)" || \return;
    \eval "$ask_conda";
    __conda_hashr
}
__docker_append_to_completions () 
{ 
    COMPREPLY=(${COMPREPLY[@]/%/"$1"})
}
__docker_complete_capabilities_addable () 
{ 
    local capabilities=(ALL CAP_AUDIT_CONTROL CAP_AUDIT_READ CAP_BLOCK_SUSPEND CAP_BPF CAP_CHECKPOINT_RESTORE CAP_DAC_READ_SEARCH CAP_IPC_LOCK CAP_IPC_OWNER CAP_LEASE CAP_LINUX_IMMUTABLE CAP_MAC_ADMIN CAP_MAC_OVERRIDE CAP_NET_ADMIN CAP_NET_BROADCAST CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_BOOT CAP_SYSLOG CAP_SYS_MODULE CAP_SYS_NICE CAP_SYS_PACCT CAP_SYS_PTRACE CAP_SYS_RAWIO CAP_SYS_RESOURCE CAP_SYS_TIME CAP_SYS_TTY_CONFIG CAP_WAKE_ALARM RESET);
    COMPREPLY=($( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ))
}
__docker_complete_capabilities_droppable () 
{ 
    local capabilities=(ALL CAP_AUDIT_WRITE CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_KILL CAP_MKNOD CAP_NET_BIND_SERVICE CAP_NET_RAW CAP_SETFCAP CAP_SETGID CAP_SETPCAP CAP_SETUID CAP_SYS_CHROOT RESET);
    COMPREPLY=($( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ))
}
__docker_complete_configs () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_configs "$@")" -- "$current"))
}
__docker_complete_container_ids () 
{ 
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names () 
{ 
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_containers "$@")" -- "$current"))
}
__docker_complete_containers_all () 
{ 
    __docker_complete_containers "$@" --all
}
__docker_complete_containers_in_network () 
{ 
    local containers=($(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1"));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_containers_removable () 
{ 
    __docker_complete_containers "$@" --filter status=created --filter status=exited
}
__docker_complete_containers_running () 
{ 
    __docker_complete_containers "$@" --filter status=running
}
__docker_complete_containers_stoppable () 
{ 
    __docker_complete_containers "$@" --filter status=running --filter status=paused
}
__docker_complete_containers_stopped () 
{ 
    __docker_complete_containers "$@" --filter status=exited
}
__docker_complete_containers_unpauseable () 
{ 
    __docker_complete_containers "$@" --filter status=paused
}
__docker_complete_contexts () 
{ 
    local contexts=($(__docker_contexts "$@"));
    COMPREPLY=($(compgen -W "${contexts[*]}" -- "$cur"))
}
__docker_complete_detach_keys () 
{ 
    case "$prev" in 
        --detach-keys)
            case "$cur" in 
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_images () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_images "$@")" -- "$current"));
    __ltrim_colon_completions "$current"
}
__docker_complete_isolation () 
{ 
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_local_interfaces () 
{ 
    local additional_interface;
    if [ "$1" = "--add" ]; then
        additional_interface="$2";
        shift 2;
    fi;
    COMPREPLY=($( compgen -W "$(__docker_local_interfaces "$@") $additional_interface" -- "$cur" ))
}
__docker_complete_local_ips () 
{ 
    __docker_complete_local_interfaces --ip-only
}
__docker_complete_log_driver_options () 
{ 
    local key=$(__docker_map_key_of_current_option '--log-opt');
    case "$key" in 
        awslogs-create-group)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        awslogs-credentials-endpoint)
            COMPREPLY=($( compgen -W "/" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        compress | fluentd-async-connect)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        fluentd-sub-second-precision)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        gelf-address)
            COMPREPLY=($( compgen -W "tcp udp" -S "://" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        gelf-compression-level)
            COMPREPLY=($( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ));
            return
        ;;
        gelf-compression-type)
            COMPREPLY=($( compgen -W "gzip none zlib" -- "${cur##*=}" ));
            return
        ;;
        line-only)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "blocking non-blocking" -- "${cur##*=}" ));
            return
        ;;
        syslog-address)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        syslog-facility)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ));
            return
        ;;
        syslog-format)
            COMPREPLY=($( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ));
            return
        ;;
        syslog-tls-ca-cert | syslog-tls-cert | syslog-tls-key)
            _filedir;
            return
        ;;
        syslog-tls-skip-verify)
            COMPREPLY=($( compgen -W "true" -- "${cur##*=}" ));
            return
        ;;
        splunk-url)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        splunk-gzip | splunk-insecureskipverify | splunk-verify-connection)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        splunk-format)
            COMPREPLY=($( compgen -W "inline json raw" -- "${cur##*=}" ));
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers () 
{ 
    COMPREPLY=($( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		local
		logentries
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels () 
{ 
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options () 
{ 
    local common_options1="max-buffer-size mode";
    local common_options2="env env-regex labels";
    local awslogs_options="$common_options1 awslogs-create-group awslogs-credentials-endpoint awslogs-datetime-format awslogs-group awslogs-multiline-pattern awslogs-region awslogs-stream tag";
    local fluentd_options="$common_options1 $common_options2 fluentd-address fluentd-async fluentd-buffer-limit fluentd-request-ack fluentd-retry-wait fluentd-max-retries fluentd-sub-second-precision tag";
    local gcplogs_options="$common_options1 $common_options2 gcp-log-cmd gcp-meta-id gcp-meta-name gcp-meta-zone gcp-project";
    local gelf_options="$common_options1 $common_options2 gelf-address gelf-compression-level gelf-compression-type gelf-tcp-max-reconnect gelf-tcp-reconnect-delay tag";
    local journald_options="$common_options1 $common_options2 tag";
    local json_file_options="$common_options1 $common_options2 compress max-file max-size";
    local local_options="$common_options1 compress max-file max-size";
    local logentries_options="$common_options1 $common_options2 line-only logentries-token tag";
    local splunk_options="$common_options1 $common_options2 splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag";
    local syslog_options="$common_options1 $common_options2 syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag";
    local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $logentries_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in 
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gcplogs)
            COMPREPLY=($( compgen -W "$gcplogs_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        local)
            COMPREPLY=($( compgen -W "$local_options" -S = -- "$cur" ))
        ;;
        logentries)
            COMPREPLY=($( compgen -W "$logentries_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_networks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_networks "$@")" -- "$current"))
}
__docker_complete_nodes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_nodes "$@")" -- "$current"))
}
__docker_complete_plugins_bundled () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current"))
}
__docker_complete_plugins_installed () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_installed "$@")" -- "$current"))
}
__docker_complete_resolved_hostname () 
{ 
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_restart () 
{ 
    case "$prev" in 
        --restart)
            case "$cur" in 
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
    esac;
    return 1
}
__docker_complete_runtimes () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_runtimes)" -- "$cur"))
}
__docker_complete_secrets () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_secrets "$@")" -- "$current"))
}
__docker_complete_services () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(__docker_services "$@" --filter "name=$current"))
}
__docker_complete_services_and_tasks () 
{ 
    COMPREPLY=($(compgen -W "$(__docker_services "$@") $(__docker_tasks)" -- "$cur"))
}
__docker_complete_signals () 
{ 
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo "$cur" | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_stack_orchestrator_options () 
{ 
    case "$prev" in 
        --kubeconfig)
            _filedir;
            return 0
        ;;
        --namespace)
            return 0
        ;;
        --orchestrator)
            COMPREPLY=($( compgen -W "all kubernetes swarm" -- "$cur"));
            return 0
        ;;
    esac;
    return 1
}
__docker_complete_stacks () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_stacks "$@")" -- "$current"))
}
__docker_complete_ulimits () 
{ 
    local limits="
		as
		chroot
		core
		cpu
		data
		fsize
		locks
		maxlogins
		maxsyslogins
		memlock
		msgqueue
		nice
		nofile
		nproc
		priority
		rss
		rtprio
		sigpending
		stack
	";
    if [ "$1" = "--rm" ]; then
        COMPREPLY=($( compgen -W "$limits" -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$limits" -S = -- "$cur" ));
        __docker_nospace;
    fi
}
__docker_complete_user_group () 
{ 
    if [[ $cur == *:* ]]; then
        COMPREPLY=($(compgen -g -- "${cur#*:}"));
    else
        COMPREPLY=($(compgen -u -S : -- "$cur"));
        __docker_nospace;
    fi
}
__docker_complete_volumes () 
{ 
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_volumes "$@")" -- "$current"))
}
__docker_configs () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_CONFIG_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q config ls --format "$format" "$@"
}
__docker_containers () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Names}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS}" = yes ]; then
                format='{{.ID}} {{.Names}}';
            else
                format='{{.Names}}';
            fi;
        fi;
    fi;
    __docker_q ps --format "$format" "$@"
}
__docker_contexts () 
{ 
    local add=();
    while true; do
        case "$1" in 
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q context ls -q;
    echo "${add[@]}"
}
__docker_fetch_info () 
{ 
    if [ -z "$info_fetched" ]; then
        read -r server_experimental server_os <<< "$(__docker_q version -f '{{.Server.Experimental}} {{.Server.Os}}')";
        info_fetched=true;
    fi
}
__docker_images () 
{ 
    local repo_format='{{.Repository}}';
    local tag_format='{{.Repository}}:{{.Tag}}';
    local id_format='{{.ID}}';
    local all;
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" = "all" ]; then
        all='--all';
    fi;
    while true; do
        case "$1" in 
            --repo)
                format+="$repo_format\n";
                shift
            ;;
            --tag)
                if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
                    format+="$tag_format\n";
                fi;
                shift
            ;;
            --id)
                if [[ $DOCKER_COMPLETION_SHOW_IMAGE_IDS =~ ^(all|non-intermediate)$ ]]; then
                    format+="$id_format\n";
                fi;
                shift
            ;;
            --force-tag)
                format+="$tag_format\n";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q image ls --no-trunc --format "${format%\\n}" $all "$@" | grep --color=auto -v '<none>$'
}
__docker_local_interfaces () 
{ 
    command -v ip > /dev/null 2>&1 || return;
    local format;
    if [ "$1" = "--ip-only" ]; then
        format='\1';
        shift;
    else
        format='\1 \2';
    fi;
    ip addr show scope global 2> /dev/null | sed -n "s| \+inet \([0-9.]\+\).* \([^ ]\+\)|$format|p"
}
__docker_map_key_of_current_option () 
{ 
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q network ls --format "$format" "$@"
}
__docker_nodes () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_NODE_IDS" = yes ]; then
        format='{{.ID}} {{.Hostname}}';
    else
        format='{{.Hostname}}';
    fi;
    local add=();
    while true; do
        case "$1" in 
            --id)
                format='{{.ID}}';
                shift
            ;;
            --name)
                format='{{.Hostname}}';
                shift
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "$(__docker_q node ls --format "$format" "$@")" "${add[@]}"
}
__docker_nospace () 
{ 
    type compopt &> /dev/null && compopt -o nospace
}
__docker_plugins_bundled () 
{ 
    local type add=() remove=();
    while true; do
        case "$1" in 
            --type)
                type="$2";
                shift 2
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            --remove)
                remove+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugins=($(__docker_q info --format "{{range \$i, \$p := .Plugins.$type}}{{.}} {{end}}"));
    for del in "${remove[@]}";
    do
        plugins=(${plugins[@]/$del/});
    done;
    echo "${plugins[@]}" "${add[@]}"
}
__docker_plugins_installed () 
{ 
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_PLUGIN_IDS" = yes ]; then
        format='{{.ID}} {{.Name}}';
    else
        format='{{.Name}}';
    fi;
    __docker_q plugin ls --format "$format" "$@"
}
__docker_pos_first_nonflag () 
{ 
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ "$counter" -le "$cword" ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in 
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo "$counter"
}
__docker_q () 
{ 
    docker ${host:+--host "$host"} ${config:+--config "$config"} ${context:+--context "$context"} "$@" 2> /dev/null
}
__docker_runtimes () 
{ 
    __docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}
__docker_secrets () 
{ 
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_SECRET_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q secret ls --format "$format" "$@"
}
__docker_server_is_experimental () 
{ 
    __docker_fetch_info;
    [ "$server_experimental" = "true" ]
}
__docker_server_os_is () 
{ 
    local expected_os="$1";
    __docker_fetch_info;
    [ "$server_os" = "$expected_os" ]
}
__docker_services () 
{ 
    local format='{{.Name}}';
    [ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS}" = yes ] && format='{{.ID}} {{.Name}}';
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        fi;
    fi;
    __docker_q service ls --quiet --format "$format" "$@"
}
__docker_stack_orchestrator_is () 
{ 
    case "$1" in 
        kubernetes)
            if [ -z "$stack_orchestrator_is_kubernetes" ]; then
                __docker_q stack ls --help | grep --color=auto -qe --namespace;
                stack_orchestrator_is_kubernetes=$?;
            fi;
            return $stack_orchestrator_is_kubernetes
        ;;
        swarm)
            if [ -z "$stack_orchestrator_is_swarm" ]; then
                __docker_q stack deploy --help | grep --color=auto -qe "with-registry-auth";
                stack_orchestrator_is_swarm=$?;
            fi;
            return $stack_orchestrator_is_swarm
        ;;
        *)
            return 1
        ;;
    esac
}
__docker_stacks () 
{ 
    __docker_q stack ls | awk 'NR>1 {print $1}'
}
__docker_subcommands () 
{ 
    local subcommands="$1";
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in 
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand//-/_};
                declare -F "$completions_func" > /dev/null && "$completions_func";
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_tasks () 
{ 
    __docker_q service ps --format '{{.ID}}' ""
}
__docker_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob () 
{ 
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option () 
{ 
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case ${words[$counter]} in 
            $option_extglob)
                echo "${words[$counter + 1]}";
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__docker_volumes () 
{ 
    __docker_q volume ls -q "$@"
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        eval $1=$(printf ~%q "${!1#\~}");
    fi
}
__fzf_cd__ () 
{ 
    local cmd dir;
    cmd="${FZF_ALT_C_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune     -o -type d -print 2> /dev/null | cut -b3-"}";
    dir=$(eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS" $(__fzfcmd) +m) && printf 'cd %q' "$dir"
}
__fzf_comprun () 
{ 
    if [[ "$(type -t _fzf_comprun 2>&1)" = function ]]; then
        _fzf_comprun "$@";
    else
        if [[ -n "$TMUX_PANE" ]] && { 
            [[ "${FZF_TMUX:-0}" != 0 ]] || [[ -n "$FZF_TMUX_OPTS" ]]
        }; then
            shift;
            fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- "$@";
        else
            shift;
            fzf "$@";
        fi;
    fi
}
__fzf_defc () 
{ 
    local cmd func opts orig_var orig def;
    cmd="$1";
    func="$2";
    opts="$3";
    orig_var="_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}";
    orig="${!orig_var}";
    if [[ -n "$orig" ]]; then
        printf -v def "$orig" "$func";
        eval "$def";
    else
        complete -F "$func" $opts "$cmd";
    fi
}
__fzf_generic_path_completion () 
{ 
    local cur base dir leftover matches trigger cmd;
    cmd="${COMP_WORDS[0]//[^A-Za-z0-9_=]/_}";
    COMPREPLY=();
    trigger=${FZF_COMPLETION_TRIGGER-'**'};
    cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ "$cur" == *"$trigger" ]]; then
        base=${cur:0:${#cur}-${#trigger}};
        eval "base=$base";
        [[ $base = *"/"* ]] && dir="$base";
        while true; do
            if [[ -z "$dir" ]] || [[ -d "$dir" ]]; then
                leftover=${base/#"$dir"};
                leftover=${leftover/#\/};
                [[ -z "$dir" ]] && dir='.';
                [[ "$dir" != "/" ]] && dir="${dir/%\//}";
                matches=$(eval "$1 $(printf %q "$dir")" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore $FZF_DEFAULT_OPTS $FZF_COMPLETION_OPTS $2" __fzf_comprun "$4" -q "$leftover" | while read -r item; do
          printf "%q$3 " "$item"
        done);
                matches=${matches% };
                [[ -z "$3" ]] && [[ "$__fzf_nospace_commands" = *" ${COMP_WORDS[0]} "* ]] && matches="$matches ";
                if [[ -n "$matches" ]]; then
                    COMPREPLY=("$matches");
                else
                    COMPREPLY=("$cur");
                fi;
                printf '\e[5n';
                return 0;
            fi;
            dir=$(dirname "$dir");
            [[ "$dir" =~ /$ ]] || dir="$dir"/;
        done;
    else
        shift;
        shift;
        shift;
        _fzf_handle_dynamic_completion "$cmd" "$@";
    fi
}
__fzf_history__ () 
{ 
    local output;
    output=$(
    builtin fc -lnr -2147483648 |
      last_hist=$(HISTTIMEFORMAT='' builtin history 1) perl -n -l0 -e 'BEGIN { getc; $/ = "\n\t"; $HISTCMD = $ENV{last_hist} + 1 } s/^[ *]//; print $HISTCMD - $. . "\t$_" if !$seen{$_}++' |
      FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort,ctrl-z:ignore $FZF_CTRL_R_OPTS +m --read0" $(__fzfcmd) --query "$READLINE_LINE"
  ) || return;
    READLINE_LINE=${output#*'	'};
    if [[ -z "$READLINE_POINT" ]]; then
        echo "$READLINE_LINE";
    else
        READLINE_POINT=0x7fffffff;
    fi
}
__fzf_orig_completion () 
{ 
    local l comp f cmd;
    while read -r l; do
        if [[ "$l" =~ ^(.*\ -F)\ *([^ ]*).*\ ([^ ]*)$ ]]; then
            comp="${BASH_REMATCH[1]}";
            f="${BASH_REMATCH[2]}";
            cmd="${BASH_REMATCH[3]}";
            [[ "$f" = _fzf_* ]] && continue;
            printf -v "_fzf_orig_completion_${cmd//[^A-Za-z0-9_]/_}" "%s" "${comp} %s ${cmd} #${f}";
            if [[ "$l" = *" -o nospace "* ]] && [[ ! "$__fzf_nospace_commands" = *" $cmd "* ]]; then
                __fzf_nospace_commands="$__fzf_nospace_commands $cmd ";
            fi;
        fi;
    done
}
__fzf_select__ () 
{ 
    local cmd="${FZF_CTRL_T_COMMAND:-"command find -L . -mindepth 1 \\( -path '*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \\) -prune     -o -type f -print     -o -type d -print     -o -type l -print 2> /dev/null | cut -b3-"}";
    eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS" $(__fzfcmd) -m "$@" | while read -r item; do
        printf '%q ' "$item";
    done;
    echo
}
__fzfcmd () 
{ 
    [[ -n "$TMUX_PANE" ]] && { 
        [[ "${FZF_TMUX:-0}" != 0 ]] || [[ -n "$FZF_TMUX_OPTS" ]]
    } && echo "fzf-tmux ${FZF_TMUX_OPTS:--d${FZF_TMUX_HEIGHT:-40%}} -- " || echo "fzf"
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                [[ $index -gt 0 ]] && ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                (( index -= old_size - new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_eread () 
{ 
    test -r "$1" && IFS='
' read "$2" < "$1"
}
__git_ps1 () 
{ 
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha="";
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if __git_sequencer_status; then
                    :;
                else
                    if [ -f "$g/BISECT_LOG" ]; then
                        r="|BISECTING";
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet || w="*";
                git diff --no-ext-diff --cached --quiet || i="+";
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    local f="$w$i$s$u";
    local gitstring="$c$b${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream" 2>/dev/null);
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
                p="$p \${__git_ps1_upstream_name}";
            else
                p="$p ${__git_ps1_upstream_name}";
                unset __git_ps1_upstream_name;
            fi;
        fi;
    fi
}
__git_sequencer_status () 
{ 
    local todo;
    if test -f "$g/CHERRY_PICK_HEAD"; then
        r="|CHERRY-PICKING";
        return 0;
    else
        if test -f "$g/REVERT_HEAD"; then
            r="|REVERTING";
            return 0;
        else
            if __git_eread "$g/sequencer/todo" todo; then
                case "$todo" in 
                    p[\ \	] | pick[\ \	]*)
                        r="|CHERRY-PICKING";
                        return 0
                    ;;
                    revert[\ \	]*)
                        r="|REVERTING";
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
__load_completion () 
{ 
    local -a dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions);
    local OIFS=$IFS IFS=: dir cmd="${1##*/}" compfile;
    [[ -n $cmd ]] || return 1;
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    do
        dirs+=($dir/bash-completion/completions);
    done;
    IFS=$OIFS;
    if [[ $BASH_SOURCE == */* ]]; then
        dirs+=("${BASH_SOURCE%/*}/completions");
    else
        dirs+=(./completions);
    fi;
    for dir in "${dirs[@]}";
    do
        [[ -d "$dir" ]] || continue;
        for compfile in "$cmd" "$cmd.bash" "_$cmd";
        do
            compfile="$dir/$compfile";
            [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 0;
        done;
    done;
    [[ -n "${_xspecs[$cmd]}" ]] && complete -F _filedir_xspec "$cmd" && return 0;
    return 1
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    local -a array=($1);
    for i in "${array[@]}";
    do
        case "$i" in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [[:blank:]]* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
                [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [[:blank:]]* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
        done;
        [[ $i == $COMP_CWORD ]] && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
__sdk_broadcast () 
{ 
    if [ "$BROADCAST_OLD_TEXT" ]; then
        __sdkman_echo_cyan "$BROADCAST_OLD_TEXT";
    else
        __sdkman_echo_cyan "$BROADCAST_LIVE_TEXT";
    fi
}
__sdk_config () 
{ 
    local -r editor=(${EDITOR:=vi});
    if ! command -v "${editor[@]}" > /dev/null; then
        __sdkman_echo_red "No default editor configured.";
        __sdkman_echo_yellow "Please set the default editor with the EDITOR environment variable.";
        return 1;
    fi;
    "${editor[@]}" "${SDKMAN_DIR}/etc/config"
}
__sdk_current () 
{ 
    local candidate="$1";
    echo "";
    if [ -n "$candidate" ]; then
        __sdkman_determine_current_version "$candidate";
        if [ -n "$CURRENT" ]; then
            __sdkman_echo_no_colour "Using ${candidate} version ${CURRENT}";
        else
            __sdkman_echo_red "Not using any version of ${candidate}";
        fi;
    else
        local installed_count=0;
        for ((i = 0; i <= ${#SDKMAN_CANDIDATES[*]}; i++))
        do
            if [[ -n ${SDKMAN_CANDIDATES[${i}]} ]]; then
                __sdkman_determine_current_version "${SDKMAN_CANDIDATES[${i}]}";
                if [ -n "$CURRENT" ]; then
                    if [ ${installed_count} -eq 0 ]; then
                        __sdkman_echo_no_colour 'Using:';
                        echo "";
                    fi;
                    __sdkman_echo_no_colour "${SDKMAN_CANDIDATES[${i}]}: ${CURRENT}";
                    ((installed_count += 1));
                fi;
            fi;
        done;
        if [ ${installed_count} -eq 0 ]; then
            __sdkman_echo_no_colour 'No candidates are in use';
        fi;
    fi
}
__sdk_default () 
{ 
    local candidate version;
    candidate="$1";
    version="$2";
    __sdkman_check_candidate_present "$candidate" || return 1;
    __sdkman_determine_version "$candidate" "$version" || return 1;
    if [ ! -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${VERSION}" ]; then
        echo "";
        __sdkman_echo_red "Stop! Candidate version is not installed.";
        echo "";
        __sdkman_echo_yellow "Tip: Run the following to install this version";
        echo "";
        __sdkman_echo_yellow "$ sdk install ${candidate} ${VERSION}";
        return 1;
    fi;
    __sdkman_link_candidate_version "$candidate" "$VERSION";
    echo "";
    __sdkman_echo_green "Default ${candidate} version set to ${VERSION}"
}
__sdk_env () 
{ 
    local -r sdkmanrc=".sdkmanrc";
    local -r subcommand="$1";
    case $subcommand in 
        "")
            __sdkman_load_env "$sdkmanrc"
        ;;
        init)
            __sdkman_create_env_file "$sdkmanrc"
        ;;
        install)
            __sdkman_setup_env "$sdkmanrc"
        ;;
        clear)
            __sdkman_clear_env "$sdkmanrc"
        ;;
    esac
}
__sdk_flush () 
{ 
    local qualifier="$1";
    case "$qualifier" in 
        broadcast)
            __sdkman_cleanup_broadcast
        ;;
        version)
            if [[ -f "${SDKMAN_DIR}/var/version" ]]; then
                rm -f "${SDKMAN_DIR}/var/version";
                __sdkman_echo_green "Version file has been flushed.";
            fi
        ;;
        archives)
            __sdkman_cleanup_folder "archives"
        ;;
        temp)
            __sdkman_cleanup_folder "tmp"
        ;;
        tmp)
            __sdkman_cleanup_folder "tmp"
        ;;
        metadata)
            __sdkman_cleanup_folder "var/metadata"
        ;;
        *)
            __sdkman_cleanup_folder "archives";
            __sdkman_cleanup_folder "tmp";
            __sdkman_cleanup_folder "var/metadata"
        ;;
    esac
}
__sdk_help () 
{ 
    __sdkman_echo_no_colour "";
    __sdkman_echo_no_colour "Usage: sdk <command> [candidate] [version]";
    __sdkman_echo_no_colour "       sdk offline <enable|disable>";
    __sdkman_echo_no_colour "";
    __sdkman_echo_no_colour "   commands:";
    __sdkman_echo_no_colour "       install   or i    <candidate> [version] [local-path]";
    __sdkman_echo_no_colour "       uninstall or rm   <candidate> <version>";
    __sdkman_echo_no_colour "       list      or ls   [candidate]";
    __sdkman_echo_no_colour "       use       or u    <candidate> <version>";
    __sdkman_echo_no_colour "       config";
    __sdkman_echo_no_colour "       default   or d    <candidate> [version]";
    __sdkman_echo_no_colour "       home      or h    <candidate> <version>";
    __sdkman_echo_no_colour "       env       or e    [init|install|clear]";
    __sdkman_echo_no_colour "       current   or c    [candidate]";
    __sdkman_echo_no_colour "       upgrade   or ug   [candidate]";
    __sdkman_echo_no_colour "       version   or v";
    __sdkman_echo_no_colour "       broadcast or b";
    __sdkman_echo_no_colour "       help";
    __sdkman_echo_no_colour "       offline           [enable|disable]";
    if [[ "$sdkman_selfupdate_feature" == "true" ]]; then
        __sdkman_echo_no_colour "       selfupdate        [force]";
    fi;
    __sdkman_echo_no_colour "       update";
    __sdkman_echo_no_colour "       flush             [archives|tmp|broadcast|metadata|version]";
    __sdkman_echo_no_colour "";
    __sdkman_echo_no_colour "   candidate  :  the SDK to install: groovy, scala, grails, gradle, kotlin, etc.";
    __sdkman_echo_no_colour "                 use list command for comprehensive list of candidates";
    __sdkman_echo_no_colour "                 eg: \$ sdk list";
    __sdkman_echo_no_colour "   version    :  where optional, defaults to latest stable if not provided";
    __sdkman_echo_no_colour "                 eg: \$ sdk install groovy";
    __sdkman_echo_no_colour "   local-path :  optional path to an existing local installation";
    __sdkman_echo_no_colour "                 eg: \$ sdk install groovy 2.4.13-local /opt/groovy-2.4.13";
    __sdkman_echo_no_colour ""
}
__sdk_home () 
{ 
    local candidate version;
    candidate="$1";
    version="$2";
    __sdkman_check_version_present "$version" || return 1;
    __sdkman_check_candidate_present "$candidate" || return 1;
    __sdkman_determine_version "$candidate" "$version" || return 1;
    if [[ ! -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]]; then
        echo "";
        __sdkman_echo_red "Stop! Candidate version is not installed.";
        echo "";
        __sdkman_echo_yellow "Tip: Run the following to install this version";
        echo "";
        __sdkman_echo_yellow "$ sdk install ${candidate} ${version}";
        return 1;
    fi;
    echo -n "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}"
}
__sdk_install () 
{ 
    local candidate version folder;
    candidate="$1";
    version="$2";
    folder="$3";
    __sdkman_check_candidate_present "$candidate" || return 1;
    __sdkman_determine_version "$candidate" "$version" "$folder" || return 1;
    if [[ -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${VERSION}" || -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/${VERSION}" ]]; then
        echo "";
        __sdkman_echo_yellow "${candidate} ${VERSION} is already installed.";
        return 0;
    fi;
    if [[ ${VERSION_VALID} == 'valid' ]]; then
        __sdkman_determine_current_version "$candidate";
        __sdkman_install_candidate_version "$candidate" "$VERSION" || return 1;
        if [[ "$sdkman_auto_answer" != 'true' && "$auto_answer_upgrade" != 'true' && -n "$CURRENT" ]]; then
            __sdkman_echo_confirm "Do you want ${candidate} ${VERSION} to be set as default? (Y/n): ";
            read USE;
        fi;
        if [[ -z "$USE" || "$USE" == "y" || "$USE" == "Y" ]]; then
            echo "";
            __sdkman_echo_green "Setting ${candidate} ${VERSION} as default.";
            __sdkman_link_candidate_version "$candidate" "$VERSION";
            __sdkman_add_to_path "$candidate";
        fi;
        return 0;
    else
        if [[ "$VERSION_VALID" == 'invalid' && -n "$folder" ]]; then
            __sdkman_install_local_version "$candidate" "$VERSION" "$folder" || return 1;
        else
            echo "";
            __sdkman_echo_red "Stop! $1 is not a valid ${candidate} version.";
            return 1;
        fi;
    fi
}
__sdk_list () 
{ 
    local candidate="$1";
    if [[ -z "$candidate" ]]; then
        __sdkman_list_candidates;
    else
        __sdkman_list_versions "$candidate";
    fi
}
__sdk_offline () 
{ 
    local mode="$1";
    if [[ -z "$mode" || "$mode" == "enable" ]]; then
        SDKMAN_OFFLINE_MODE="true";
        __sdkman_echo_green "Offline mode enabled.";
    fi;
    if [[ "$mode" == "disable" ]]; then
        SDKMAN_OFFLINE_MODE="false";
        __sdkman_echo_green "Online mode re-enabled!";
    fi
}
__sdk_selfupdate () 
{ 
    local force_selfupdate;
    force_selfupdate="$1";
    if [[ "$SDKMAN_AVAILABLE" == "false" ]]; then
        echo "This command is not available while offline.";
    else
        if [[ "$SDKMAN_REMOTE_VERSION" == "$SDKMAN_VERSION" && "$force_selfupdate" != "force" ]]; then
            echo "No update available at this time.";
        else
            if [[ "$sdkman_beta_channel" == "true" ]]; then
                export sdkman_debug_mode;
                __sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/selfupdate/beta" | bash;
            else
                export sdkman_debug_mode;
                __sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/selfupdate/stable" | bash;
            fi;
        fi;
    fi
}
__sdk_uninstall () 
{ 
    local candidate version current;
    candidate="$1";
    version="$2";
    __sdkman_check_candidate_present "$candidate" || return 1;
    __sdkman_check_version_present "$version" || return 1;
    current=$(readlink "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" | sed "s!${SDKMAN_CANDIDATES_DIR}/${candidate}/!!g");
    if [[ -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" && "$version" == "$current" ]]; then
        echo "";
        __sdkman_echo_green "Deselecting ${candidate} ${version}...";
        unlink "${SDKMAN_CANDIDATES_DIR}/${candidate}/current";
    fi;
    echo "";
    if [ -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]; then
        __sdkman_echo_green "Uninstalling ${candidate} ${version}...";
        rm -rf "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}";
    else
        __sdkman_echo_red "${candidate} ${version} is not installed.";
    fi
}
__sdk_update () 
{ 
    local candidates_uri="${SDKMAN_CANDIDATES_API}/candidates/all";
    __sdkman_echo_debug "Using candidates endpoint: $candidates_uri";
    local fresh_candidates_csv=$(__sdkman_secure_curl_with_timeouts "$candidates_uri");
    __sdkman_echo_debug "Local candidates: $SDKMAN_CANDIDATES_CSV";
    __sdkman_echo_debug "Fetched candidates: $fresh_candidates_csv";
    if [[ -n "${fresh_candidates_csv}" ]] && ! grep --color=auto -iq 'html' <<< "${fresh_candidates_csv}"; then
        __sdkman_echo_debug "Fresh and cached candidate lengths: ${#fresh_candidates_csv} ${#SDKMAN_CANDIDATES_CSV}";
        local fresh_candidates combined_candidates diff_candidates;
        if [[ "${zsh_shell}" == 'true' ]]; then
            fresh_candidates=(${(s:,:)fresh_candidates_csv});
        else
            IFS=',' read -a fresh_candidates <<< "${fresh_candidates_csv}";
        fi;
        combined_candidates=("${fresh_candidates[@]}" "${SDKMAN_CANDIDATES[@]}");
        diff_candidates=($(printf '%s
' "${combined_candidates[@]}" | sort | uniq -u));
        if ((${#diff_candidates[@]})); then
            local delta;
            delta=("${fresh_candidates[@]}" "${diff_candidates[@]}");
            delta=($(printf '%s
' "${delta[@]}" | sort | uniq -d));
            if ((${#delta[@]})); then
                __sdkman_echo_green "\nAdding new candidates(s): ${delta[*]}";
            fi;
            delta=("${SDKMAN_CANDIDATES[@]}" "${diff_candidates[@]}");
            delta=($(printf '%s
' "${delta[@]}" | sort | uniq -d));
            if ((${#delta[@]})); then
                __sdkman_echo_green "\nRemoving obsolete candidates(s): ${delta[*]}";
            fi;
            echo "${fresh_candidates_csv}" >| "${SDKMAN_CANDIDATES_CACHE}";
            __sdkman_echo_yellow '
Please open a new terminal now...';
        else
            touch "${SDKMAN_CANDIDATES_CACHE}";
            __sdkman_echo_green '
No new candidates found at this time.';
        fi;
    fi
}
__sdk_upgrade () 
{ 
    local all candidates candidate upgradable installed_count upgradable_count upgradable_candidates;
    if [ -n "$1" ]; then
        all=false;
        candidates=$1;
    else
        all=true;
        if [[ "$zsh_shell" == 'true' ]]; then
            candidates=(${SDKMAN_CANDIDATES[@]});
        else
            candidates=${SDKMAN_CANDIDATES[@]};
        fi;
    fi;
    installed_count=0;
    upgradable_count=0;
    echo "";
    for candidate in ${candidates};
    do
        upgradable="$(__sdkman_determine_upgradable_version "$candidate")";
        case $? in 
            1)
                $all || __sdkman_echo_red "Not using any version of ${candidate}"
            ;;
            2)
                echo "";
                __sdkman_echo_red "Stop! Could not get remote version of ${candidate}";
                return 1
            ;;
            *)
                if [ -n "$upgradable" ]; then
                    [ ${upgradable_count} -eq 0 ] && __sdkman_echo_no_colour "Available defaults:";
                    __sdkman_echo_no_colour "$upgradable";
                    ((upgradable_count += 1));
                    upgradable_candidates=(${upgradable_candidates[@]} $candidate);
                fi;
                ((installed_count += 1))
            ;;
        esac;
    done;
    if $all; then
        if [ ${installed_count} -eq 0 ]; then
            __sdkman_echo_no_colour 'No candidates are in use';
        else
            if [ ${upgradable_count} -eq 0 ]; then
                __sdkman_echo_no_colour "All candidates are up-to-date";
            fi;
        fi;
    else
        if [ ${upgradable_count} -eq 0 ]; then
            __sdkman_echo_no_colour "${candidate} is up-to-date";
        fi;
    fi;
    if [ ${upgradable_count} -gt 0 ]; then
        echo "";
        if [[ "$sdkman_auto_answer" != 'true' ]]; then
            __sdkman_echo_confirm "Use prescribed default version(s)? (Y/n): ";
            read UPGRADE_ALL;
        fi;
        export auto_answer_upgrade='true';
        if [[ -z "$UPGRADE_ALL" || "$UPGRADE_ALL" == "y" || "$UPGRADE_ALL" == "Y" ]]; then
            for ((i = 0; i <= ${#upgradable_candidates[*]}; i++))
            do
                upgradable_candidate="${upgradable_candidates[${i}]}";
                if [[ -n "$upgradable_candidate" ]]; then
                    __sdk_install $upgradable_candidate;
                fi;
            done;
        fi;
        unset auto_answer_upgrade;
    fi
}
__sdk_use () 
{ 
    local candidate version install;
    candidate="$1";
    version="$2";
    __sdkman_check_version_present "$version" || return 1;
    __sdkman_check_candidate_present "$candidate" || return 1;
    if [[ ! -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]]; then
        echo "";
        __sdkman_echo_red "Stop! Candidate version is not installed.";
        echo "";
        __sdkman_echo_yellow "Tip: Run the following to install this version";
        echo "";
        __sdkman_echo_yellow "$ sdk install ${candidate} ${version}";
        return 1;
    fi;
    __sdkman_set_candidate_home "$candidate" "$version";
    if [[ $PATH =~ ${SDKMAN_CANDIDATES_DIR}/${candidate}/([^/]+) ]]; then
        local matched_version;
        if [[ "$zsh_shell" == "true" ]]; then
            matched_version=${match[1]};
        else
            matched_version=${BASH_REMATCH[1]};
        fi;
        export PATH=${PATH//${SDKMAN_CANDIDATES_DIR}\/${candidate}\/${matched_version}/${SDKMAN_CANDIDATES_DIR}\/${candidate}\/${version}};
    fi;
    if [[ ! ( -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" || -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" ) ]]; then
        __sdkman_echo_green "Setting ${candidate} version ${version} as default.";
        __sdkman_link_candidate_version "$candidate" "$version";
    fi;
    echo "";
    __sdkman_echo_green "Using ${candidate} version ${version} in this shell."
}
__sdk_version () 
{ 
    echo "";
    __sdkman_echo_yellow "SDKMAN ${SDKMAN_VERSION}"
}
__sdkman_add_to_path () 
{ 
    local candidate present;
    candidate="$1";
    present=$(__sdkman_path_contains "$candidate");
    if [[ "$present" == 'false' ]]; then
        PATH="$SDKMAN_CANDIDATES_DIR/$candidate/current/bin:$PATH";
    fi
}
__sdkman_auto_update () 
{ 
    local remote_version version delay_upgrade;
    remote_version="$1";
    version="$2";
    delay_upgrade="${SDKMAN_DIR}/var/delay_upgrade";
    if [[ -n "$(find "$delay_upgrade" -mtime +1)" && "$remote_version" != "$version" ]]; then
        echo "";
        echo "";
        __sdkman_echo_yellow "ATTENTION: A new version of SDKMAN is available...";
        echo "";
        __sdkman_echo_no_colour "The current version is $remote_version, but you have $version.";
        echo "";
        if [[ "$sdkman_auto_answer" == false ]]; then
            __sdkman_echo_confirm "Would you like to upgrade now? (Y/n): ";
            read upgrade;
        fi;
        if [[ -z "$upgrade" ]]; then
            upgrade="Y";
        fi;
        if [[ "$upgrade" == "Y" || "$upgrade" == "y" ]]; then
            __sdk_selfupdate "force";
            unset upgrade;
        else
            __sdkman_echo_no_colour "Not upgrading today...";
        fi;
        touch "$delay_upgrade";
    fi
}
__sdkman_build_version_csv () 
{ 
    local candidate versions_csv;
    candidate="$1";
    versions_csv="";
    if [[ -d "${SDKMAN_CANDIDATES_DIR}/${candidate}" ]]; then
        for version in $(find "${SDKMAN_CANDIDATES_DIR}/${candidate}" -maxdepth 1 -mindepth 1 \( -type l -o -type d \) -exec basename '{}' \; | sort -r);
        do
            if [[ "$version" != 'current' ]]; then
                versions_csv="${version},${versions_csv}";
            fi;
        done;
        versions_csv=${versions_csv%?};
    fi;
    echo "$versions_csv"
}
__sdkman_check_candidate_present () 
{ 
    local candidate="$1";
    if [ -z "$candidate" ]; then
        echo "";
        __sdkman_echo_red "No candidate provided.";
        __sdk_help;
        return 1;
    fi
}
__sdkman_check_version_present () 
{ 
    local version="$1";
    if [ -z "$version" ]; then
        echo "";
        __sdkman_echo_red "No candidate version provided.";
        __sdk_help;
        return 1;
    fi
}
__sdkman_checksum_zip () 
{ 
    local -r zip_archive="$1";
    local -r headers_file="$2";
    local algorithm checksum cmd;
    local shasum_avail=false;
    local md5sum_avail=false;
    if [ -z "${headers_file}" ]; then
        echo "";
        __sdkman_echo_debug "Skipping checksum for cached artifact";
        return;
    else
        if [ ! -f "${headers_file}" ]; then
            echo "";
            __sdkman_echo_yellow "Metadata file not found at '${headers_file}', skipping checksum...";
            return;
        fi;
    fi;
    if [[ "$sdkman_checksum_enable" != "true" ]]; then
        echo "";
        __sdkman_echo_yellow "Checksums are disabled, skipping verification...";
        return;
    fi;
    if command -v shasum > /dev/null 2>&1; then
        shasum_avail=true;
    fi;
    if command -v md5sum > /dev/null 2>&1; then
        md5sum_avail=true;
    fi;
    while IFS= read -r line; do
        algorithm=$(echo $line | sed -n 's/^X-Sdkman-Checksum-\(.*\):.*$/\1/p' | tr '[:lower:]' '[:upper:]');
        checksum=$(echo $line | sed -n 's/^X-Sdkman-Checksum-.*:\(.*\)$/\1/p' | tr -cd '[:alnum:]');
        if [[ -n ${algorithm} && -n ${checksum} ]]; then
            if [[ "$algorithm" =~ 'SHA' && "$shasum_avail" == 'true' ]]; then
                cmd="echo \"${checksum} *${zip_archive}\" | shasum --check --quiet";
            else
                if [[ "$algorithm" =~ 'MD5' && "$md5sum_avail" == 'true' ]]; then
                    cmd="echo \"${checksum} ${zip_archive}\" | md5sum --check --quiet";
                fi;
            fi;
            if [[ -n $cmd ]]; then
                __sdkman_echo_no_colour "Verifying artifact: ${zip_archive} (${algorithm}:${checksum})";
                if ! eval "$cmd"; then
                    rm -f "$zip_archive";
                    echo "";
                    __sdkman_echo_red "Stop! An invalid checksum was detected and the archive removed! Please try re-installing.";
                    return 1;
                fi;
            else
                __sdkman_echo_no_colour "Not able to perform checksum verification at this time.";
            fi;
        fi;
    done < ${headers_file}
}
__sdkman_cleanup_broadcast () 
{ 
    if [[ -f "${SDKMAN_DIR}/var/broadcast_id" ]]; then
        rm -f "${SDKMAN_DIR}/var/broadcast_id";
        rm -f "${SDKMAN_DIR}/var/broadcast";
        __sdkman_echo_green "Broadcast has been flushed.";
    else
        __sdkman_echo_no_colour "No prior broadcast found so not flushed.";
    fi
}
__sdkman_cleanup_folder () 
{ 
    local folder="$1";
    local sdkman_cleanup_dir;
    local sdkman_cleanup_disk_usage;
    local sdkman_cleanup_count;
    sdkman_cleanup_dir="${SDKMAN_DIR}/${folder}";
    sdkman_cleanup_disk_usage=$(du -sh "$sdkman_cleanup_dir");
    sdkman_cleanup_count=$(ls -1 "$sdkman_cleanup_dir" | wc -l);
    rm -rf "$sdkman_cleanup_dir";
    mkdir "$sdkman_cleanup_dir";
    __sdkman_echo_green "${sdkman_cleanup_count} archive(s) flushed, freeing ${sdkman_cleanup_disk_usage}."
}
__sdkman_clear_env () 
{ 
    local sdkmanrc="$1";
    if [[ -z $SDKMAN_ENV ]]; then
        __sdkman_echo_red "No environment currently set!";
        return 1;
    fi;
    if [[ ! -f ${SDKMAN_ENV}/${sdkmanrc} ]]; then
        __sdkman_echo_red "Could not find ${SDKMAN_ENV}/${sdkmanrc}.";
        return 1;
    fi;
    __sdkman_env_each_candidate "${SDKMAN_ENV}/${sdkmanrc}" "__sdkman_env_restore_default_version";
    unset SDKMAN_ENV
}
__sdkman_complete_candidate_version () 
{ 
    local -r command=$1;
    local -r candidate=$2;
    local -r candidate_version=$3;
    local -a candidates;
    case $command in 
        default | d | home | h | uninstall | rm | use | u)
            local -r version_paths=("${SDKMAN_CANDIDATES_DIR}/${candidate}"/*);
            for version_path in "${version_paths[@]}";
            do
                [[ $version_path = *current ]] && continue;
                candidates+=("${version_path##*/}");
            done
        ;;
        install | i)
            while IFS= read -r -d, version || [[ -n "$version" ]]; do
                candidates+=("$version");
            done <<< "$(curl --silent "${SDKMAN_CANDIDATES_API}/candidates/$candidate/${SDKMAN_PLATFORM}/versions/all")"
        ;;
    esac;
    COMPREPLY=($(compgen -W "${candidates[*]}" -- "$candidate_version"))
}
__sdkman_complete_command () 
{ 
    local -r command=$1;
    local -r current_word=$2;
    local -a candidates;
    case $command in 
        sdk)
            candidates=("install" "uninstall" "list" "use" "config" "default" "home" "env" "current" "upgrade" "version" "broadcast" "help" "offline" "selfupdate" "update" "flush")
        ;;
        current | c | default | d | home | h | uninstall | rm | upgrade | ug | use | u)
            local -r candidate_paths=("${SDKMAN_CANDIDATES_DIR}"/*);
            for candidate_path in "${candidate_paths[@]}";
            do
                candidates+=("${candidate_path##*/}");
            done
        ;;
        install | i | list | ls)
            candidates=${SDKMAN_CANDIDATES[@]}
        ;;
        env | e)
            candidates=("init" "install" "clear")
        ;;
        offline)
            candidates=("enable" "disable")
        ;;
        selfupdate)
            candidates=("force")
        ;;
        flush)
            candidates=("archives" "temp" "broadcast" "version")
        ;;
    esac;
    COMPREPLY=($(compgen -W "${candidates[*]}" -- "$current_word"))
}
__sdkman_create_env_file () 
{ 
    local sdkmanrc="$1";
    if [[ -f "$sdkmanrc" ]]; then
        __sdkman_echo_red "$sdkmanrc already exists!";
        return 1;
    fi;
    __sdkman_determine_current_version "java";
    local version;
    [[ -n "$CURRENT" ]] && version="$CURRENT" || version="$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/candidates/default/java")";
    cat <<-eof >| "$sdkmanrc"
# Enable auto-env through the sdkman_auto_env config
# Add key=value pairs of SDKs to use below
java=$version
eof

    __sdkman_echo_green "$sdkmanrc created."
}
__sdkman_determine_broadcast_id () 
{ 
    if [[ "$SDKMAN_OFFLINE_MODE" == "true" || "$COMMAND" == "offline" && "$QUALIFIER" == "enable" ]]; then
        echo "";
    else
        echo $(__sdkman_secure_curl_with_timeouts "${SDKMAN_CANDIDATES_API}/broadcast/latest/id");
    fi
}
__sdkman_determine_candidate_bin_dir () 
{ 
    local candidate_dir="$1";
    if [[ -d "${candidate_dir}/bin" ]]; then
        echo "${candidate_dir}/bin";
    else
        echo "$candidate_dir";
    fi
}
__sdkman_determine_current_version () 
{ 
    local candidate present;
    candidate="$1";
    present=$(__sdkman_path_contains "${SDKMAN_CANDIDATES_DIR}/${candidate}");
    if [[ "$present" == 'true' ]]; then
        if [[ $PATH =~ ${SDKMAN_CANDIDATES_DIR}/${candidate}/([^/]+)/bin ]]; then
            if [[ "$zsh_shell" == "true" ]]; then
                CURRENT=${match[1]};
            else
                CURRENT=${BASH_REMATCH[1]};
            fi;
        fi;
        if [[ "$CURRENT" == "current" ]]; then
            CURRENT=$(readlink "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" | sed "s!${SDKMAN_CANDIDATES_DIR}/${candidate}/!!g");
        fi;
    else
        CURRENT="";
    fi
}
__sdkman_determine_upgradable_version () 
{ 
    local candidate local_versions remote_default_version;
    candidate="$1";
    local_versions="$(echo $(find "${SDKMAN_CANDIDATES_DIR}/${candidate}" -maxdepth 1 -mindepth 1 -type d -exec basename '{}' \; 2> /dev/null) | sed -e "s/ /, /g")";
    if [ ${#local_versions} -eq 0 ]; then
        return 1;
    fi;
    remote_default_version="$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/candidates/default/${candidate}")";
    if [ -z "$remote_default_version" ]; then
        return 2;
    fi;
    if [ ! -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${remote_default_version}" ]; then
        __sdkman_echo_yellow "${candidate} (local: ${local_versions}; default: ${remote_default_version})";
    fi
}
__sdkman_determine_version () 
{ 
    local candidate version folder;
    candidate="$1";
    version="$2";
    folder="$3";
    if [[ "$SDKMAN_AVAILABLE" == "false" && -n "$version" && -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]]; then
        VERSION="$version";
    else
        if [[ "$SDKMAN_AVAILABLE" == "false" && -z "$version" && -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" ]]; then
            VERSION=$(readlink "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" | sed "s!${SDKMAN_CANDIDATES_DIR}/${candidate}/!!g");
        else
            if [[ "$SDKMAN_AVAILABLE" == "false" && -n "$version" ]]; then
                __sdkman_echo_red "Stop! ${candidate} ${version} is not available while offline.";
                return 1;
            else
                if [[ "$SDKMAN_AVAILABLE" == "false" && -z "$version" ]]; then
                    __sdkman_echo_red "This command is not available while offline.";
                    return 1;
                else
                    if [[ -z "$version" ]]; then
                        version=$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/candidates/default/${candidate}");
                    fi;
                    local validation_url="${SDKMAN_CANDIDATES_API}/candidates/validate/${candidate}/${version}/$(echo $SDKMAN_PLATFORM | tr '[:upper:]' '[:lower:]')";
                    VERSION_VALID=$(__sdkman_secure_curl "$validation_url");
                    __sdkman_echo_debug "Validate $candidate $version for $SDKMAN_PLATFORM: $VERSION_VALID";
                    __sdkman_echo_debug "Validation URL: $validation_url";
                    if [[ "$VERSION_VALID" == 'valid' || "$VERSION_VALID" == 'invalid' && -n "$folder" ]]; then
                        VERSION="$version";
                    else
                        if [[ "$VERSION_VALID" == 'invalid' && -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]]; then
                            VERSION="$version";
                        else
                            if [[ "$VERSION_VALID" == 'invalid' && -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}" ]]; then
                                VERSION="$version";
                            else
                                if [[ -z "$version" ]]; then
                                    version="\b";
                                fi;
                                echo "";
                                __sdkman_echo_red "Stop! $candidate $version is not available. Possible causes:";
                                __sdkman_echo_red " * $version is an invalid version";
                                __sdkman_echo_red " * $candidate binaries are incompatible with your platform";
                                __sdkman_echo_red " * $candidate has not been released yet";
                                echo "";
                                __sdkman_echo_yellow "Tip: see all available versions for your platform:";
                                echo "";
                                __sdkman_echo_yellow "  $ sdk list $candidate";
                                return 1;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
__sdkman_display_offline_warning () 
{ 
    local broadcast_id="$1";
    if [[ -z "$broadcast_id" && "$COMMAND" != "offline" && "$SDKMAN_OFFLINE_MODE" != "true" ]]; then
        __sdkman_echo_red "==== INTERNET NOT REACHABLE! ===================================================";
        __sdkman_echo_red "";
        __sdkman_echo_red " Some functionality is disabled or only partially available.";
        __sdkman_echo_red " If this persists, please enable the offline mode:";
        __sdkman_echo_red "";
        __sdkman_echo_red "   $ sdk offline";
        __sdkman_echo_red "";
        __sdkman_echo_red "================================================================================";
        echo "";
    fi
}
__sdkman_display_proxy_warning () 
{ 
    __sdkman_echo_red "==== PROXY DETECTED! ===========================================================";
    __sdkman_echo_red "Please ensure you have open internet access to continue.";
    __sdkman_echo_red "================================================================================";
    echo ""
}
__sdkman_download () 
{ 
    local candidate version archives_folder;
    candidate="$1";
    version="$2";
    archives_folder="${SDKMAN_DIR}/archives";
    metadata_folder="${SDKMAN_DIR}/var/metadata";
    mkdir -p ${metadata_folder};
    if [ ! -f "${archives_folder}/${candidate}-${version}.zip" ]; then
        local platform_parameter="$(echo $SDKMAN_PLATFORM | tr '[:upper:]' '[:lower:]')";
        local download_url="${SDKMAN_CANDIDATES_API}/broker/download/${candidate}/${version}/${platform_parameter}";
        local base_name="${candidate}-${version}";
        local zip_archive_target="${SDKMAN_DIR}/archives/${base_name}.zip";
        local tmp_headers_file="${SDKMAN_DIR}/tmp/${base_name}.headers.tmp";
        local headers_file="${metadata_folder}/${base_name}.headers";
        local pre_installation_hook="${SDKMAN_DIR}/tmp/hook_pre_${candidate}_${version}.sh";
        __sdkman_echo_debug "Get pre-installation hook: ${SDKMAN_CANDIDATES_API}/hooks/pre/${candidate}/${version}/${platform_parameter}";
        __sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/hooks/pre/${candidate}/${version}/${platform_parameter}" >| "$pre_installation_hook";
        __sdkman_echo_debug "Copy remote pre-installation hook: $pre_installation_hook";
        source "$pre_installation_hook";
        __sdkman_pre_installation_hook || return 1;
        __sdkman_echo_debug "Completed pre-installation hook...";
        export local binary_input="${SDKMAN_DIR}/tmp/${base_name}.bin";
        export local zip_output="${SDKMAN_DIR}/tmp/$base_name.zip";
        echo "";
        __sdkman_echo_no_colour "Downloading: ${candidate} ${version}";
        echo "";
        __sdkman_echo_no_colour "In progress...";
        echo "";
        __sdkman_secure_curl_download "${download_url}" --output "${binary_input}" --dump-header "${tmp_headers_file}";
        grep --color=auto '^X-Sdkman' "${tmp_headers_file}" > "${headers_file}";
        __sdkman_echo_debug "Downloaded binary to: ${binary_input} (HTTP headers written to: ${headers_file})";
        local post_installation_hook="${SDKMAN_DIR}/tmp/hook_post_${candidate}_${version}.sh";
        __sdkman_echo_debug "Get post-installation hook: ${SDKMAN_CANDIDATES_API}/hooks/post/${candidate}/${version}/${platform_parameter}";
        __sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/hooks/post/${candidate}/${version}/${platform_parameter}" >| "$post_installation_hook";
        __sdkman_echo_debug "Copy remote post-installation hook: ${post_installation_hook}";
        source "$post_installation_hook";
        __sdkman_post_installation_hook || return 1;
        __sdkman_echo_debug "Processed binary as: $zip_output";
        __sdkman_echo_debug "Completed post-installation hook...";
        command mv -i -f "$zip_output" "$zip_archive_target";
        __sdkman_echo_debug "Moved to archive folder: $zip_archive_target";
    else
        echo "";
        __sdkman_echo_no_colour "Found a previously downloaded ${candidate} ${version} archive. Not downloading it again...";
    fi;
    __sdkman_validate_zip "${archives_folder}/${candidate}-${version}.zip" || return 1;
    __sdkman_checksum_zip "${archives_folder}/${candidate}-${version}.zip" "${headers_file}" || return 1;
    echo ""
}
__sdkman_echo () 
{ 
    if [[ "$sdkman_colour_enable" == 'false' ]]; then
        echo -e "$2";
    else
        echo -e "\033[1;$1$2\033[0m";
    fi
}
__sdkman_echo_confirm () 
{ 
    if [[ "$sdkman_colour_enable" == 'false' ]]; then
        echo -n "$1";
    else
        echo -e -n "\033[1;33m$1\033[0m";
    fi
}
__sdkman_echo_cyan () 
{ 
    __sdkman_echo "36m" "$1"
}
__sdkman_echo_debug () 
{ 
    if [[ "$sdkman_debug_mode" == 'true' ]]; then
        echo "$1";
    fi
}
__sdkman_echo_green () 
{ 
    __sdkman_echo "32m" "$1"
}
__sdkman_echo_no_colour () 
{ 
    echo "$1"
}
__sdkman_echo_paged () 
{ 
    if [[ -n "$PAGER" ]]; then
        echo "$@" | eval "$PAGER";
    else
        if command -v less &> /dev/null; then
            echo "$@" | less;
        else
            echo "$@";
        fi;
    fi
}
__sdkman_echo_red () 
{ 
    __sdkman_echo "31m" "$1"
}
__sdkman_echo_yellow () 
{ 
    __sdkman_echo "33m" "$1"
}
__sdkman_env_each_candidate () 
{ 
    local -r filepath=$1;
    local -r func=$2;
    local normalised_line;
    while IFS= read -r line || [[ -n "$line" ]]; do
        normalised_line="$(__sdkman_normalise "$line")";
        __sdkman_is_blank_line "$normalised_line" && continue;
        if ! __sdkman_matches_candidate_format "$normalised_line"; then
            __sdkman_echo_red "Invalid candidate format!";
            echo "";
            __sdkman_echo_yellow "Expected 'candidate=version' but found '$normalised_line'";
            return 1;
        fi;
        $func "${normalised_line%=*}" "${normalised_line#*=}";
    done < "$filepath"
}
__sdkman_env_restore_default_version () 
{ 
    local -r candidate="$1";
    local candidate_dir default_version;
    candidate_dir="${SDKMAN_CANDIDATES_DIR}/${candidate}/current";
    if __sdkman_is_symlink $candidate_dir; then
        default_version=$(basename $(readlink ${candidate_dir}));
        __sdk_use "$candidate" "$default_version" > /dev/null && __sdkman_echo_yellow "Restored $candidate version to $default_version (default)";
    else
        __sdkman_echo_yellow "No default version of $candidate was found";
    fi
}
__sdkman_export_candidate_home () 
{ 
    local candidate_name="$1";
    local candidate_dir="$2";
    local candidate_home_var="$(echo ${candidate_name} | tr '[:lower:]' '[:upper:]')_HOME";
    export $(echo "$candidate_home_var")="$candidate_dir"
}
__sdkman_install_candidate_version () 
{ 
    local candidate version;
    candidate="$1";
    version="$2";
    __sdkman_download "$candidate" "$version" || return 1;
    __sdkman_echo_green "Installing: ${candidate} ${version}";
    mkdir -p "${SDKMAN_CANDIDATES_DIR}/${candidate}";
    rm -rf "${SDKMAN_DIR}/tmp/out";
    unzip -oq "${SDKMAN_DIR}/archives/${candidate}-${version}.zip" -d "${SDKMAN_DIR}/tmp/out";
    command mv -i -f "$SDKMAN_DIR"/tmp/out/* "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}";
    __sdkman_echo_green "Done installing!";
    echo ""
}
__sdkman_install_local_version () 
{ 
    local candidate version folder version_length version_length_max;
    version_length_max=15;
    candidate="$1";
    version="$2";
    folder="$3";
    version_length=${#version};
    __sdkman_echo_debug "Validating that actual version length ($version_length) does not exceed max ($version_length_max)";
    if [[ $version_length -gt $version_length_max ]]; then
        __sdkman_echo_red "Invalid version! ${version} with length ${version_length} exceeds max of ${version_length_max}!";
        return 1;
    fi;
    mkdir -p "${SDKMAN_CANDIDATES_DIR}/${candidate}";
    if [[ "$folder" != /* ]]; then
        folder="$(pwd)/$folder";
    fi;
    if [[ -d "$folder" ]]; then
        __sdkman_echo_green "Linking ${candidate} ${version} to ${folder}";
        ln -s "$folder" "${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}";
        __sdkman_echo_green "Done installing!";
    else
        __sdkman_echo_red "Invalid path! Refusing to link ${candidate} ${version} to ${folder}.";
        return 1;
    fi;
    echo ""
}
__sdkman_is_blank_line () 
{ 
    [[ -z "$1" ]]
}
__sdkman_is_symlink () 
{ 
    [[ -h "$1" ]]
}
__sdkman_link_candidate_version () 
{ 
    local candidate version;
    candidate="$1";
    version="$2";
    if [[ -L "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" || -d "${SDKMAN_CANDIDATES_DIR}/${candidate}/current" ]]; then
        rm -rf "${SDKMAN_CANDIDATES_DIR}/${candidate}/current";
    fi;
    ln -s "${version}" "${SDKMAN_CANDIDATES_DIR}/${candidate}/current"
}
__sdkman_list_candidates () 
{ 
    if [[ "$SDKMAN_AVAILABLE" == "false" ]]; then
        __sdkman_echo_red "This command is not available while offline.";
    else
        __sdkman_echo_paged "$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/candidates/list")";
    fi
}
__sdkman_list_versions () 
{ 
    local candidate versions_csv;
    candidate="$1";
    versions_csv="$(__sdkman_build_version_csv "$candidate")";
    __sdkman_determine_current_version "$candidate";
    if [[ "$SDKMAN_AVAILABLE" == "false" ]]; then
        __sdkman_offline_list "$candidate" "$versions_csv";
    else
        __sdkman_echo_paged "$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/candidates/${candidate}/${SDKMAN_PLATFORM}/versions/list?current=${CURRENT}&installed=${versions_csv}")";
    fi
}
__sdkman_load_env () 
{ 
    local sdkmanrc="$1";
    if [[ ! -f "$sdkmanrc" ]]; then
        __sdkman_echo_red "Could not find $sdkmanrc in the current directory.";
        echo "";
        __sdkman_echo_yellow "Run 'sdk env init' to create it.";
        return 1;
    fi;
    __sdkman_env_each_candidate "$sdkmanrc" "__sdk_use" && SDKMAN_ENV=$PWD
}
__sdkman_matches_candidate_format () 
{ 
    [[ "$1" =~ ^[[:lower:]]+\=.+$ ]]
}
__sdkman_normalise () 
{ 
    local -r line_without_comments="${1/\#*/}";
    echo "${line_without_comments//[[:space:]]/}"
}
__sdkman_offline_list () 
{ 
    local candidate versions_csv;
    candidate="$1";
    versions_csv="$2";
    __sdkman_echo_no_colour "--------------------------------------------------------------------------------";
    __sdkman_echo_yellow "Offline: only showing installed ${candidate} versions";
    __sdkman_echo_no_colour "--------------------------------------------------------------------------------";
    local versions=($(echo ${versions_csv//,/ }));
    for ((i = ${#versions} - 1; i >= 0; i--))
    do
        if [[ -n "${versions[${i}]}" ]]; then
            if [[ "${versions[${i}]}" == "$CURRENT" ]]; then
                __sdkman_echo_no_colour " > ${versions[${i}]}";
            else
                __sdkman_echo_no_colour " * ${versions[${i}]}";
            fi;
        fi;
    done;
    if [[ -z "${versions[@]}" ]]; then
        __sdkman_echo_yellow "   None installed!";
    fi;
    __sdkman_echo_no_colour "--------------------------------------------------------------------------------";
    __sdkman_echo_no_colour "* - installed                                                                   ";
    __sdkman_echo_no_colour "> - currently in use                                                            ";
    __sdkman_echo_no_colour "--------------------------------------------------------------------------------"
}
__sdkman_path_contains () 
{ 
    local candidate exists;
    candidate="$1";
    exists="$(echo "$PATH" | grep "$candidate")";
    if [[ -n "$exists" ]]; then
        echo 'true';
    else
        echo 'false';
    fi
}
__sdkman_prepend_candidate_to_path () 
{ 
    local candidate_dir candidate_bin_dir;
    candidate_dir="$1";
    candidate_bin_dir=$(__sdkman_determine_candidate_bin_dir "$candidate_dir");
    echo "$PATH" | grep --color=auto -q "$candidate_dir" || PATH="${candidate_bin_dir}:${PATH}";
    unset CANDIDATE_BIN_DIR
}
__sdkman_secure_curl () 
{ 
    if [[ "${sdkman_insecure_ssl}" == 'true' ]]; then
        curl --insecure --silent --location "$1";
    else
        curl --silent --location "$1";
    fi
}
__sdkman_secure_curl_download () 
{ 
    local curl_params;
    curl_params=('--progress-bar' '--location');
    if [[ "${sdkman_debug_mode}" == 'true' ]]; then
        curl_params+=('--verbose');
    fi;
    if [[ "${sdkman_curl_continue}" == 'true' ]]; then
        curl_params+=('-C' '-');
    fi;
    if [[ -n "${sdkman_curl_retry_max_time}" ]]; then
        curl_params+=('--retry-max-time' "${sdkman_curl_retry_max_time}");
    fi;
    if [[ -n "${sdkman_curl_retry}" ]]; then
        curl_params+=('--retry' "${sdkman_curl_retry}");
    fi;
    if [[ "${sdkman_insecure_ssl}" == 'true' ]]; then
        curl_params+=('--insecure');
    fi;
    curl "${curl_params[@]}" "${@}"
}
__sdkman_secure_curl_with_timeouts () 
{ 
    if [[ "${sdkman_insecure_ssl}" == 'true' ]]; then
        curl --insecure --silent --location --connect-timeout ${sdkman_curl_connect_timeout} --max-time ${sdkman_curl_max_time} "$1";
    else
        curl --silent --location --connect-timeout ${sdkman_curl_connect_timeout} --max-time ${sdkman_curl_max_time} "$1";
    fi
}
__sdkman_set_availability () 
{ 
    local broadcast_id="$1";
    local detect_html="$(echo "$broadcast_id" | tr '[:upper:]' '[:lower:]' | grep 'html')";
    if [[ -z "$broadcast_id" ]]; then
        SDKMAN_AVAILABLE="false";
        __sdkman_display_offline_warning "$broadcast_id";
    else
        if [[ -n "$detect_html" ]]; then
            SDKMAN_AVAILABLE="false";
            __sdkman_display_proxy_warning;
        else
            SDKMAN_AVAILABLE="true";
        fi;
    fi
}
__sdkman_set_candidate_home () 
{ 
    local candidate version upper_candidate;
    candidate="$1";
    version="$2";
    upper_candidate=$(echo "$candidate" | tr '[:lower:]' '[:upper:]');
    export "${upper_candidate}_HOME"="${SDKMAN_CANDIDATES_DIR}/${candidate}/${version}"
}
__sdkman_setup_env () 
{ 
    local sdkmanrc="$1";
    if [[ ! -f "$sdkmanrc" ]]; then
        __sdkman_echo_red "Could not find $sdkmanrc in the current directory.";
        echo "";
        __sdkman_echo_yellow "Run 'sdk env init' to create it.";
        return 1;
    fi;
    sdkman_auto_answer="true" USE="n" __sdkman_env_each_candidate "$sdkmanrc" "__sdk_install";
    __sdkman_load_env "$sdkmanrc"
}
__sdkman_update_broadcast () 
{ 
    local broadcast_live_id broadcast_id_file broadcast_text_file broadcast_old_id;
    broadcast_live_id="$1";
    broadcast_id_file="${SDKMAN_DIR}/var/broadcast_id";
    broadcast_text_file="${SDKMAN_DIR}/var/broadcast";
    broadcast_old_id="";
    if [[ -f "$broadcast_id_file" ]]; then
        broadcast_old_id=$(< "$broadcast_id_file");
    fi;
    if [[ -f "$broadcast_text_file" ]]; then
        BROADCAST_OLD_TEXT=$(< "$broadcast_text_file");
    fi;
    if [[ "$SDKMAN_AVAILABLE" == "true" && "$broadcast_live_id" != "$broadcast_old_id" && "$COMMAND" != "selfupdate" && "$COMMAND" != "flush" ]]; then
        mkdir -p "${SDKMAN_DIR}/var";
        echo "$broadcast_live_id" | tee "$broadcast_id_file" > /dev/null;
        BROADCAST_LIVE_TEXT=$(__sdkman_secure_curl "${SDKMAN_CANDIDATES_API}/broadcast/latest");
        echo "$BROADCAST_LIVE_TEXT" | tee "$broadcast_text_file" > /dev/null;
        if [[ "$COMMAND" != "broadcast" ]]; then
            __sdkman_echo_cyan "$BROADCAST_LIVE_TEXT";
        fi;
    fi
}
__sdkman_update_broadcast_and_service_availability () 
{ 
    local broadcast_live_id=$(__sdkman_determine_broadcast_id);
    __sdkman_set_availability "$broadcast_live_id";
    __sdkman_update_broadcast "$broadcast_live_id"
}
__sdkman_validate_zip () 
{ 
    local zip_archive zip_ok;
    zip_archive="$1";
    zip_ok=$(unzip -t "$zip_archive" | grep 'No errors detected in compressed data');
    if [ -z "$zip_ok" ]; then
        rm -f "$zip_archive";
        echo "";
        __sdkman_echo_red "Stop! The archive was corrupt and has been removed! Please try installing again.";
        return 1;
    fi
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -g -- "$1"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -Gn 2>/dev/null || groups 2>/dev/null)" -- "$1"));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -u -- "${1:-$cur}"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -un 2>/dev/null || whoami 2>/dev/null)" -- "${1:-$cur}"));
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help --save -v --version --tag -w --window';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions="--tag";
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version --tag -w --window';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -w | --window)
            dashoptions="--save --tag";
            COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
        ;;
        -h | --help | -v | --version | --tag)
            return 0
        ;;
        *)
            dashoptions='--tag';
            if ! [[ "${COMP_WORDS[*]}" =~ .*--save.* ]]; then
                dashoptions="--save $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--window.* || "${COMP_WORDS[*]}" =~ .*\ -w\ .* ]]; then
                dashoptions="-w --window $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--symptom.* || "${COMP_WORDS[*]}" =~ .*\ -s\ .* ]]; then
                dashoptions="-s --symptom $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--update.* || "${COMP_WORDS[*]}" =~ .*\ -u\ .* ]]; then
                dashoptions="-u --update $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--file-bug.* || "${COMP_WORDS[*]}" =~ .*\ -f\ .* ]]; then
                dashoptions="-f --file-bug $dashoptions";
            fi;
            if ! [[ "${COMP_WORDS[*]}" =~ .*--crash-file.* || "${COMP_WORDS[*]}" =~ .*\ -c\ .* ]]; then
                dashoptions="-c --crash-file $dashoptions";
            fi;
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package --tag" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        --tag)
            return 0
        ;;
        *)
            if [[ "${COMP_WORDS[*]}" =~ .*\ -p.* || "${COMP_WORDS[*]}" =~ .*--package.* ]]; then
                COMPREPLY=($( compgen -W "--tag" -- $cur));
            else
                COMPREPLY=($( compgen -W "-p --package --tag" -- $cur));
            fi
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    if [ -r /usr/share/apport/symptoms ]; then
        for FILE in $(ls /usr/share/apport/symptoms);
        do
            if [[ ! "$FILE" =~ ^_.* && -n $(egrep "^def run\s*\(.*\):" /usr/share/apport/symptoms/$FILE) ]]; then
                syms="$syms ${FILE%.py}";
            fi;
        done;
    fi;
    echo $syms
}
_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY=($({
        if [[ ${1:-} == -w ]]; then
            iwconfig
        elif [[ ${1:-} == -a ]]; then
            ifconfig || ip link show up
        else
            ifconfig -a || ip link show
        fi
    } 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }'));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur"))
}
_benchmark_names () 
{ 
    _get_names_from_array "bench"
}
_bin_names () 
{ 
    _get_names_from_array "bin"
}
_cargo () 
{ 
    local cur prev words cword;
    _get_comp_words_by_ref cur prev words cword;
    COMPREPLY=();
    local nwords=${#words[@]};
    local cmd_i cmd dd_i;
    for ((cmd_i=1; cmd_i<$nwords; cmd_i++ ))
    do
        if [[ ! "${words[$cmd_i]}" =~ ^[+-] ]]; then
            cmd="${words[$cmd_i]}";
            break;
        fi;
    done;
    for ((dd_i=1; dd_i<$nwords-1; dd_i++ ))
    do
        if [[ "${words[$dd_i]}" = "--" ]]; then
            break;
        fi;
    done;
    local vcs='git hg none pijul fossil';
    local color='auto always never';
    local msg_format='human json short';
    local opt_help='-h --help';
    local opt_verbose='-v --verbose';
    local opt_quiet='-q --quiet';
    local opt_color='--color';
    local opt_common="$opt_help $opt_verbose $opt_quiet $opt_color";
    local opt_pkg_spec='-p --package --all --exclude --workspace';
    local opt_pkg='-p --package';
    local opt_feat='--features --all-features --no-default-features';
    local opt_mani='--manifest-path';
    local opt_jobs='-j --jobs';
    local opt_force='-f --force';
    local opt_sync='-s --sync';
    local opt_lock='--frozen --locked --offline';
    local opt_targets="--lib --bin --bins --example --examples --test --tests --bench --benches --all-targets";
    local opt___nocmd="$opt_common -V --version --list --explain";
    local opt__bench="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets --message-format --target --no-run --no-fail-fast --target-dir";
    local opt__build="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets --message-format --target --release --profile --target-dir";
    local opt__b="$opt__build";
    local opt__check="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets --message-format --target --release --profile --target-dir";
    local opt__c="$opt__check";
    local opt__clean="$opt_common $opt_pkg $opt_mani $opt_lock --target --release --doc --target-dir --profile";
    local opt__doc="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock $opt_jobs --message-format --bin --bins --lib --target --open --no-deps --release --document-private-items --target-dir --profile";
    local opt__d="$opt__doc";
    local opt__fetch="$opt_common $opt_mani $opt_lock --target";
    local opt__fix="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_jobs $opt_targets $opt_lock --release --target --message-format --broken-code --edition --edition-idioms --allow-no-vcs --allow-dirty --allow-staged --profile --target-dir";
    local opt__generate_lockfile="$opt_common $opt_mani $opt_lock";
    local opt__help="$opt_help";
    local opt__init="$opt_common $opt_lock --bin --lib --name --vcs --edition --registry";
    local opt__install="$opt_common $opt_feat $opt_jobs $opt_lock $opt_force --bin --bins --branch --debug --example --examples --git --list --path --rev --root --tag --version --registry --target --profile --no-track";
    local opt__locate_project="$opt_common $opt_mani $opt_lock --message-format --workspace";
    local opt__login="$opt_common $opt_lock --registry";
    local opt__metadata="$opt_common $opt_feat $opt_mani $opt_lock --format-version=1 --no-deps --filter-platform";
    local opt__new="$opt_common $opt_lock --vcs --bin --lib --name --edition --registry";
    local opt__owner="$opt_common $opt_lock -a --add -r --remove -l --list --index --token --registry";
    local opt__package="$opt_common $opt_mani $opt_feat $opt_lock $opt_jobs --allow-dirty -l --list --no-verify --no-metadata --target --target-dir";
    local opt__pkgid="$opt_common $opt_mani $opt_lock $opt_pkg";
    local opt__publish="$opt_common $opt_mani $opt_feat $opt_lock $opt_jobs --allow-dirty --dry-run --token --no-verify --index --registry --target --target-dir";
    local opt__read_manifest="$opt_help $opt_quiet $opt_verbose $opt_mani $opt_color $opt_lock --no-deps";
    local opt__run="$opt_common $opt_pkg $opt_feat $opt_mani $opt_lock $opt_jobs --message-format --target --bin --example --release --target-dir --profile";
    local opt__r="$opt__run";
    local opt__rustc="$opt_common $opt_pkg $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets -L --crate-type --extern --message-format --profile --target --release --target-dir";
    local opt__rustdoc="$opt_common $opt_pkg $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets --message-format --target --release --open --target-dir --profile";
    local opt__search="$opt_common $opt_lock --limit --index --registry";
    local opt__test="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock $opt_jobs $opt_targets --message-format --doc --target --no-run --release --no-fail-fast --target-dir --profile";
    local opt__t="$opt__test";
    local opt__tree="$opt_common $opt_pkg_spec $opt_feat $opt_mani $opt_lock --target -i --invert --prefix --no-dedupe --duplicates -d --charset -f --format -e --edges";
    local opt__uninstall="$opt_common $opt_lock $opt_pkg --bin --root";
    local opt__update="$opt_common $opt_mani $opt_lock $opt_pkg --aggressive --precise --dry-run";
    local opt__vendor="$opt_common $opt_mani $opt_lock $opt_sync --no-delete --respect-source-config --versioned-dirs";
    local opt__verify_project="$opt_common $opt_mani $opt_lock";
    local opt__version="$opt_common $opt_lock";
    local opt__yank="$opt_common $opt_lock --vers --undo --index --token --registry";
    local opt__libtest="--help --include-ignored --ignored --test --bench --list --logfile --nocapture --test-threads --skip -q --quiet --exact --color --format";
    if [[ $cword -gt $dd_i ]]; then
        if [[ "${cmd}" = @(test|bench) ]]; then
            COMPREPLY=($( compgen -W "${opt__libtest}" -- "$cur" ));
        else
            _filedir;
        fi;
    else
        if [[ $cword -le $cmd_i ]]; then
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W "${opt___nocmd}" -- "$cur" ));
            else
                if [[ "$cur" == +* ]]; then
                    COMPREPLY=($( compgen -W "$(_toolchains)" -- "$cur" ));
                else
                    COMPREPLY=($( compgen -W "$__cargo_commands" -- "$cur" ));
                fi;
            fi;
        else
            case "${prev}" in 
                --vcs)
                    COMPREPLY=($( compgen -W "$vcs" -- "$cur" ))
                ;;
                --color)
                    COMPREPLY=($( compgen -W "$color" -- "$cur" ))
                ;;
                --message-format)
                    COMPREPLY=($( compgen -W "$msg_format" -- "$cur" ))
                ;;
                --manifest-path)
                    _filedir toml
                ;;
                --bin)
                    COMPREPLY=($( compgen -W "$(_bin_names)" -- "$cur" ))
                ;;
                --test)
                    COMPREPLY=($( compgen -W "$(_test_names)" -- "$cur" ))
                ;;
                --bench)
                    COMPREPLY=($( compgen -W "$(_benchmark_names)" -- "$cur" ))
                ;;
                --example)
                    COMPREPLY=($( compgen -W "$(_get_examples)" -- "$cur" ))
                ;;
                --target)
                    COMPREPLY=($( compgen -W "$(_get_targets)" -- "$cur" ))
                ;;
                --target-dir)
                    _filedir -d
                ;;
                help)
                    COMPREPLY=($( compgen -W "$__cargo_commands" -- "$cur" ))
                ;;
                *)
                    local opt_var=opt__${cmd//-/_};
                    if [[ -z "${!opt_var}" ]]; then
                        _filedir;
                    else
                        COMPREPLY=($( compgen -W "${!opt_var}" -- "$cur" ));
                    fi
                ;;
            esac;
        fi;
    fi;
    return 0
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $(compgen -d -- $i/$cur);
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return
}
_cd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}"))
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset 'COMP_WORDS[i]';
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($(compgen -d -c -- "$cur"));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$(complete -p $cmd 2>/dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p ${cmd##*/} 2>/dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$(complete -p $compcmd 2>/dev/null);
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($(eval compgen "$cspec" -- '$cur'));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local cmd="${1:-_EmptycmD_}";
    __load_completion "$cmd" && return 124;
    complete -F _minimal -- "$cmd" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($(compgen -W "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces /etc/network/interfaces.d/* 2>/dev/null)"             -- "$cur"));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($(compgen -W "$(command ls -B             /etc/sysconfig/interfaces |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            else
                COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for ((i=1; i < cword; i++ ))
    do
        if [[ ${words[i]} != -* && ${words[i-1]} != $2 || ${words[i]} == $3 ]]; then
            (( args++ ));
        fi;
    done
}
_deno () 
{ 
    local i cur prev opts cmds;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmd="";
    opts="";
    for i in ${COMP_WORDS[@]};
    do
        case "${i}" in 
            deno)
                cmd="deno"
            ;;
            bundle)
                cmd+="__bundle"
            ;;
            cache)
                cmd+="__cache"
            ;;
            compile)
                cmd+="__compile"
            ;;
            completions)
                cmd+="__completions"
            ;;
            coverage)
                cmd+="__coverage"
            ;;
            doc)
                cmd+="__doc"
            ;;
            eval)
                cmd+="__eval"
            ;;
            fmt)
                cmd+="__fmt"
            ;;
            help)
                cmd+="__help"
            ;;
            info)
                cmd+="__info"
            ;;
            install)
                cmd+="__install"
            ;;
            lint)
                cmd+="__lint"
            ;;
            lsp)
                cmd+="__lsp"
            ;;
            repl)
                cmd+="__repl"
            ;;
            run)
                cmd+="__run"
            ;;
            test)
                cmd+="__test"
            ;;
            types)
                cmd+="__types"
            ;;
            uninstall)
                cmd+="__uninstall"
            ;;
            upgrade)
                cmd+="__upgrade"
            ;;
            *)

            ;;
        esac;
    done;
    case "${cmd}" in 
        deno)
            opts=" -q -h -V -L  --unstable --quiet --help --version --log-level   bundle cache compile completions coverage doc eval fmt info install uninstall lsp lint repl run test types upgrade help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__bundle)
            opts=" -h -V -q -c -r -L  --no-remote --no-check --lock-write --watch --help --version --unstable --quiet --import-map --config --reload --lock --cert --log-level  <source_file> <out_file> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__cache)
            opts=" -h -V -q -c -r -L  --no-remote --no-check --lock-write --help --version --unstable --quiet --import-map --config --reload --lock --cert --log-level  <file>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__compile)
            opts=" -A -h -V -q -c -r -o -L  --no-remote --no-check --lock-write --allow-hrtime --allow-all --prompt --cached-only --enable-testing-features-do-not-use --compat --help --version --unstable --quiet --import-map --config --reload --lock --cert --allow-read --allow-write --allow-net --unsafely-ignore-certificate-errors --allow-env --allow-run --allow-ffi --location --v8-flags --seed --output --target --log-level  <SCRIPT_ARG>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-read)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-write)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-net)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --unsafely-ignore-certificate-errors)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-env)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-run)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-ffi)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --output)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -o)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -W "x86_64-unknown-linux-gnu x86_64-pc-windows-msvc x86_64-apple-darwin aarch64-apple-darwin" -- "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__completions)
            opts=" -h -V -q -L  --help --version --unstable --quiet --log-level  <shell> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__coverage)
            opts=" -h -V -q -L  --lcov --help --version --unstable --quiet --ignore --include --exclude --log-level  <files>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --ignore)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --include)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --exclude)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__doc)
            opts=" -h -V -q -r -L  --json --private --help --version --unstable --quiet --import-map --reload --log-level  <source_file> <filter> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__eval)
            opts=" -T -p -h -V -q -c -r -L  --no-remote --no-check --lock-write --cached-only --enable-testing-features-do-not-use --compat --ts --print --help --version --unstable --quiet --import-map --config --reload --lock --cert --inspect --inspect-brk --location --v8-flags --seed --ext --log-level  <CODE_ARG>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect-brk)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --ext)
                    COMPREPLY=($(compgen -W "ts tsx js jsx" -- "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__fmt)
            opts=" -h -V -q -c -L  --check --watch --options-use-tabs --options-single-quote --help --version --unstable --quiet --config --ext --ignore --options-line-width --options-indent-width --options-prose-wrap --log-level  <files>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --ext)
                    COMPREPLY=($(compgen -W "ts tsx js jsx md json jsonc" -- "${cur}"));
                    return 0
                ;;
                --ignore)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --options-line-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --options-indent-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --options-prose-wrap)
                    COMPREPLY=($(compgen -W "always never preserve" -- "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__help)
            opts=" -h -V -q -L  --help --version --unstable --quiet --log-level  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__info)
            opts=" -h -V -q -r -L  --no-check --json --help --version --unstable --quiet --reload --cert --location --import-map --log-level  <file> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__install)
            opts=" -A -f -h -V -q -c -r -n -L  --no-remote --no-check --lock-write --allow-hrtime --allow-all --prompt --cached-only --enable-testing-features-do-not-use --compat --force --help --version --unstable --quiet --import-map --config --reload --lock --cert --allow-read --allow-write --allow-net --unsafely-ignore-certificate-errors --allow-env --allow-run --allow-ffi --inspect --inspect-brk --location --v8-flags --seed --name --root --log-level  <cmd>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-read)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-write)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-net)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --unsafely-ignore-certificate-errors)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-env)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-run)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-ffi)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect-brk)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --name)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -n)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --root)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__lint)
            opts=" -h -V -q -c -L  --rules --json --watch --help --version --unstable --quiet --rules-tags --rules-include --rules-exclude --config --ignore --log-level  <files>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --rules-tags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --rules-include)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --rules-exclude)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --ignore)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__lsp)
            opts=" -h -V -q -L  --help --version --unstable --quiet --log-level  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__repl)
            opts=" -h -V -q -c -r -L  --no-remote --no-check --lock-write --cached-only --enable-testing-features-do-not-use --compat --help --version --unstable --quiet --import-map --config --reload --lock --cert --inspect --inspect-brk --location --v8-flags --seed --eval --log-level  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect-brk)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --eval)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__run)
            opts=" -A -h -V -q -c -r -L  --no-remote --no-check --lock-write --allow-hrtime --allow-all --prompt --cached-only --enable-testing-features-do-not-use --compat --watch --help --version --unstable --quiet --import-map --config --reload --lock --cert --allow-read --allow-write --allow-net --unsafely-ignore-certificate-errors --allow-env --allow-run --allow-ffi --inspect --inspect-brk --location --v8-flags --seed --log-level  <SCRIPT_ARG>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-read)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-write)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-net)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --unsafely-ignore-certificate-errors)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-env)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-run)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-ffi)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect-brk)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__test)
            opts=" -A -h -V -q -c -r -j -L  --no-remote --no-check --lock-write --allow-hrtime --allow-all --prompt --cached-only --enable-testing-features-do-not-use --compat --no-run --doc --allow-none --watch --help --version --unstable --quiet --import-map --config --reload --lock --cert --allow-read --allow-write --allow-net --unsafely-ignore-certificate-errors --allow-env --allow-run --allow-ffi --inspect --inspect-brk --location --v8-flags --seed --ignore --fail-fast --filter --shuffle --coverage --jobs --log-level  <files>... <SCRIPT_ARG>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --import-map)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --config)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --reload)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -r)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --lock)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-read)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-write)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-net)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --unsafely-ignore-certificate-errors)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-env)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-run)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --allow-ffi)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --inspect-brk)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --location)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --v8-flags)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --seed)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --ignore)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --fail-fast)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --filter)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --shuffle)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --coverage)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --jobs)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__types)
            opts=" -h -V -q -L  --help --version --unstable --quiet --log-level  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__uninstall)
            opts=" -h -V -q -L  --help --version --unstable --quiet --root --log-level  <name> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --root)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        deno__upgrade)
            opts=" -f -h -q -L  --dry-run --force --canary --help --unstable --quiet --version --output --cert --log-level  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --version)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --output)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cert)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --log-level)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                -L)
                    COMPREPLY=($(compgen -W "debug info" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
    esac
}
_docker () 
{ 
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local management_commands=(builder config container context image manifest network node plugin secret service stack swarm system trust volume);
    local top_level_commands=(build login logout run search version);
    local legacy_commands=(attach commit cp create diff events exec export history images import info inspect kill load logs pause port ps pull push rename restart rm rmi save start stats stop tag top unpause update wait);
    local experimental_server_commands=(checkpoint);
    local commands=(${management_commands[*]} ${top_level_commands[*]});
    [ -z "$DOCKER_HIDE_LEGACY_COMMANDS" ] && commands+=(${legacy_commands[*]});
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--context -c
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local info_fetched server_experimental server_os;
    local stack_orchestrator_is_kubernetes stack_orchestrator_is_swarm;
    local host config context;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in 
            docker)
                return 0
            ;;
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            --context | -c)
                (( counter++ ));
                context="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local binary="${words[0]}";
    if [[ $binary == ?(*/)dockerd ]]; then
        command=daemon;
        command_pos=0;
    fi;
    local completions_func=_docker_${command//-/_};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach () 
{ 
    _docker_container_attach
}
_docker_build () 
{ 
    _docker_image_build
}
_docker_builder () 
{ 
    local subcommands="
		build
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_builder_build () 
{ 
    _docker_image_build
}
_docker_builder_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -S = -W "description id inuse parent private shared type until unused-for" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --keep-storage)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter --force -f --help --keep-storage" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint () 
{ 
    local subcommands="
		create
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint_create () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help --leave-running" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_checkpoint_ls () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_checkpoint_rm () 
{ 
    case "$prev" in 
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    COMPREPLY=($( compgen -W "$(__docker_q checkpoint ls "$prev" | sed 1d)" -- "$cur" ));
                fi;
            fi
        ;;
    esac
}
_docker_commit () 
{ 
    _docker_container_commit
}
_docker_config () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_config_create () 
{ 
    case "$prev" in 
        --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_config_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_config_list () 
{ 
    _docker_config_ls
}
_docker_config_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_configs --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_configs --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_config_remove () 
{ 
    _docker_config_rm
}
_docker_config_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_container () 
{ 
    local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	";
    local aliases="
		list
		ps
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_container_attach () 
{ 
    __docker_complete_detach_keys && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_commit () 
{ 
    case "$prev" in 
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_container_cp () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--archive -a --follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                case "$cur" in 
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "${COMPREPLY[*]}" = *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ "$cword" -eq "$counter" ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_container_create () 
{ 
    _docker_container_run_and_create
}
_docker_container_diff () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_exec () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --env-file)
            _filedir;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --env -e --env-file --help --interactive -i --privileged -t --tty -u --user --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_export () 
{ 
    case "$prev" in 
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_inspect () 
{ 
    _docker_inspect --type container
}
_docker_container_kill () 
{ 
    case "$prev" in 
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_list () 
{ 
    _docker_container_ls
}
_docker_container_logs () 
{ 
    case "$prev" in 
        --since | --tail | -n | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --since --tail -n --timestamps -t --until" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|-n|--until');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        ancestor)
            __docker_complete_images --cur "${cur##*=}" --repo --tag --id;
            return
        ;;
        before)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        expose | publish)
            return
        ;;
        id)
            __docker_complete_containers_all --cur "${cur##*=}" --id;
            return
        ;;
        health)
            COMPREPLY=($( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ));
            return
        ;;
        is-task)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_containers_all --cur "${cur##*=}" --name;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        since)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor before exited expose health id is-task label name network publish since status volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --last | -n)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ))
        ;;
    esac
}
_docker_container_pause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_port () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_container_ps () 
{ 
    _docker_container_ls
}
_docker_container_rename () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_restart () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in 
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_removable
        ;;
    esac
}
_docker_container_run () 
{ 
    _docker_container_run_and_create
}
_docker_container_run_and_create () 
{ 
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroupns
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-cgroup-rule
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--domainname
		--entrypoint
		--env -e
		--env-file
		--expose
		--gpus
		--group-add
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname -h
		--ip
		--ip6
		--ipc
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--mount
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--publish -p
		--pull
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    __docker_server_os_is windows && options_with_args+="
		--cpu-count
		--cpu-percent
		--io-maxbandwidth
		--io-maxiops
		--isolation
	";
    __docker_server_is_experimental && options_with_args+="
		--platform
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--init
		--interactive -i
		--no-healthcheck
		--oom-kill-disable
		--privileged
		--publish-all -P
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ] || [ "$subcommand" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach_keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    __docker_complete_log_driver_options && return;
    __docker_complete_restart && return;
    local key=$(__docker_map_key_of_current_option '--security-opt');
    case "$key" in 
        label)
            [[ $cur == *: ]] && return;
            COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "${cur##*=}"));
            if [ "${COMPREPLY[*]}" != "disable" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        seccomp)
            local cur=${cur##*=};
            _filedir;
            COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ));
            return
        ;;
    esac;
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --cgroupns)
            COMPREPLY=($( compgen -W "host private" -- "$cur" ));
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in 
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in 
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'none host private shareable container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            if __docker_server_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pid)
            case "$cur" in 
                *:*)
                    __docker_complete_containers_running --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pull)
            COMPREPLY=($( compgen -W 'always missing never' -- "$cur" ));
            return
        ;;
        --runtime)
            __docker_complete_runtimes;
            return
        ;;
        --security-opt)
            COMPREPLY=($( compgen -W "apparmor= label= no-new-privileges seccomp= systempaths=unconfined" -- "$cur"));
            if [[ ${COMPREPLY[*]} = *= ]]; then
                __docker_nospace;
            fi;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --storage-opt)
            COMPREPLY=($( compgen -W "size" -S = -- "$cur"));
            __docker_nospace;
            return
        ;;
        --ulimit)
            __docker_complete_ulimits;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --userns)
            COMPREPLY=($( compgen -W "host" -- "$cur" ));
            return
        ;;
        --volume-driver)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag --id;
            fi
        ;;
    esac
}
_docker_container_start () 
{ 
    __docker_complete_detach_keys && return;
    case "$prev" in 
        --checkpoint)
            if __docker_server_is_experimental; then
                return;
            fi
        ;;
        --checkpoint-dir)
            if __docker_server_is_experimental; then
                _filedir -d;
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--attach -a --detach-keys --help --interactive -i";
            __docker_server_is_experimental && options+=" --checkpoint --checkpoint-dir";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_stats () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --format --help --no-stream --no-trunc" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_stop () 
{ 
    case "$prev" in 
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stoppable
        ;;
    esac
}
_docker_container_top () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_unpause () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_container_update () 
{ 
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpus
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--pids-limit
		--restart
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    __docker_complete_restart && return;
    case "$prev" in 
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_wait () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_context () 
{ 
    local subcommands="
		create
		export
		import
		inspect
		ls
		rm
		update
		use
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_context_create () 
{ 
    case "$prev" in 
        --default-stack-orchestrator)
            COMPREPLY=($( compgen -W "all kubernetes swarm" -- "$cur" ));
            return
        ;;
        --description | --docker | --kubernetes)
            return
        ;;
        --from)
            __docker_complete_contexts;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--default-stack-orchestrator --description --docker --from --help --kubernetes" -- "$cur" ))
        ;;
    esac
}
_docker_context_export () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --kubeconfig" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir;
                fi;
            fi
        ;;
    esac
}
_docker_context_import () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                :;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir;
                fi;
            fi
        ;;
    esac
}
_docker_context_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_contexts
        ;;
    esac
}
_docker_context_list () 
{ 
    _docker_context_ls
}
_docker_context_ls () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_context_remove () 
{ 
    _docker_context_rm
}
_docker_context_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_contexts
        ;;
    esac
}
_docker_context_update () 
{ 
    case "$prev" in 
        --default-stack-orchestrator)
            COMPREPLY=($( compgen -W "all kubernetes swarm" -- "$cur" ));
            return
        ;;
        --description | --docker | --kubernetes)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--default-stack-orchestrator --description --docker --help --kubernetes" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts;
            fi
        ;;
    esac
}
_docker_context_use () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts --add default;
            fi
        ;;
    esac
}
_docker_cp () 
{ 
    _docker_container_cp
}
_docker_create () 
{ 
    _docker_container_create
}
_docker_daemon () 
{ 
    local boolean_options="
		$global_boolean_options
		--experimental
		--help
		--icc=false
		--init
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ip6tables
		--ipv6
		--live-restore
		--no-new-privileges
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
		--version -v
	";
    local options_with_args="
		$global_options_with_args
		--add-runtime
		--allow-nondistributable-artifacts
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--cluster-advertise
		--cluster-store
		--cluster-store-opt
		--config-file
		--containerd
		--containerd-namespace
		--containerd-plugins-namespace
		--cpu-rt-period
		--cpu-rt-runtime
		--data-root
		--default-address-pool
		--default-gateway
		--default-gateway-v6
		--default-runtime
		--default-shm-size
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--max-download-attempts
		--metrics-addr
		--mtu
		--network-control-plane-mtu
		--node-generic-resource
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--swarm-default-advertise-addr
		--userland-proxy-path
		--userns-remap
	";
    __docker_complete_log_driver_options && return;
    key=$(__docker_map_key_of_current_option '--cluster-store-opt');
    case "$key" in 
        kv.*file)
            cur=${cur##*=};
            _filedir;
            return
        ;;
    esac;
    local key=$(__docker_map_key_of_current_option '--storage-opt');
    case "$key" in 
        dm.blkdiscard | dm.override_udev_sync_check | dm.use_deferred_removal | dm.use_deferred_deletion)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        dm.directlvm_device | dm.thinpooldev)
            cur=${cur##*=};
            _filedir;
            return
        ;;
        dm.fs)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur##*=}" ));
            return
        ;;
        dm.libdm_log_level)
            COMPREPLY=($( compgen -W "2 3 4 5 6 7" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --authorization-plugin)
            __docker_complete_plugins_bundled --type Authorization;
            return
        ;;
        --cluster-store)
            COMPREPLY=($( compgen -W "consul etcd zk" -S "://" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cluster-store-opt)
            COMPREPLY=($( compgen -W "discovery.heartbeat discovery.ttl kv.cacertfile kv.certfile kv.keyfile kv.path" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --config-file | --containerd | --init-path | --pidfile | -p | --tlscacert | --tlscert | --tlskey | --userland-proxy-path)
            _filedir;
            return
        ;;
        --default-ulimit)
            __docker_complete_ulimits;
            return
        ;;
        --exec-root | --data-root)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs overlay2 vfs zfs" -- "$(echo "$cur" | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local btrfs_options="btrfs.min_space";
            local overlay2_options="overlay2.size";
            local zfs_options="zfs.fsname";
            local all_options="$btrfs_options $overlay2_options $zfs_options";
            case $(__docker_value_of_option '--storage-driver|-s') in 
                '')
                    COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
                ;;
                btrfs)
                    COMPREPLY=($( compgen -W "$btrfs_options" -S = -- "$cur" ))
                ;;
                overlay2)
                    COMPREPLY=($( compgen -W "$overlay2_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --metrics-addr)
            __docker_complete_local_ips;
            __docker_append_to_completions ":";
            __docker_nospace;
            return
        ;;
        --seccomp-profile)
            _filedir json;
            return
        ;;
        --swarm-default-advertise-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --userns-remap)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_diff () 
{ 
    _docker_container_diff
}
_docker_docker () 
{ 
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in 
        --config)
            _filedir -d;
            return
        ;;
        --context | -c)
            __docker_complete_contexts;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$(__docker_to_extglob "$global_options_with_args")" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_server_is_experimental && commands+=(${experimental_server_commands[*]});
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events () 
{ 
    _docker_system_events
}
_docker_exec () 
{ 
    _docker_container_exec
}
_docker_export () 
{ 
    _docker_container_export
}
_docker_help () 
{ 
    local counter=$(__docker_pos_first_nonflag);
    if [ "$cword" -eq "$counter" ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history () 
{ 
    _docker_image_history
}
_docker_image () 
{ 
    local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	";
    local aliases="
		images
		list
		remove
		rmi
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_image_build () 
{ 
    local options_with_args="
		--add-host
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--iidfile
		--label
		--memory -m
		--memory-swap
		--network
		--shm-size
		--tag -t
		--target
		--ulimit
	";
    __docker_server_os_is windows && options_with_args+="
		--isolation
	";
    local boolean_options="
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    if __docker_server_is_experimental; then
        options_with_args+="
			--platform
		";
        boolean_options+="
			--squash
		";
    fi;
    if [ "$DOCKER_BUILDKIT" = "1" ]; then
        options_with_args+="
			--output -o
			--platform
			--progress
			--secret
			--ssh
		";
    else
        boolean_options+="
			--compress
		";
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in 
        --add-host)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cache-from)
            __docker_complete_images --repo --tag --id;
            return
        ;;
        --file | -f | --iidfile)
            _filedir;
            return
        ;;
        --isolation)
            if __docker_server_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --network)
            case "$cur" in 
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --progress)
            COMPREPLY=($( compgen -W "auto plain tty" -- "$cur" ));
            return
        ;;
        --tag | -t)
            __docker_complete_images --repo --tag;
            return
        ;;
        --target)
            local context_pos=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            local context="${words[$context_pos]}";
            context="${context:-.}";
            local file="$( __docker_value_of_option '--file|f' )";
            local default_file="${context%/}/Dockerfile";
            local dockerfile="${file:-$default_file}";
            local targets="$( sed -n 's/^FROM .\+ AS \(.\+\)/\1/p' "$dockerfile" 2>/dev/null )";
            COMPREPLY=($( compgen -W "$targets" -- "$cur" ));
            return
        ;;
        --ulimit)
            __docker_complete_ulimits;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_image_history () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_image_images () 
{ 
    _docker_image_ls
}
_docker_image_import () 
{ 
    case "$prev" in 
        --change | -c | --message | -m | --platform)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--change -c --help --message -m";
            __docker_server_is_experimental && options+=" --platform";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                _filedir;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_image_inspect () 
{ 
    _docker_inspect --type image
}
_docker_image_list () 
{ 
    _docker_image_ls
}
_docker_image_load () 
{ 
    case "$prev" in 
        --input | -i | "<")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --input -i --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_image_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        before | since)
            __docker_complete_images --cur "${cur##*=}" --force-tag --id;
            return
        ;;
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        label)
            return
        ;;
        reference)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "before dangling label reference since" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_images --repo --tag
        ;;
    esac
}
_docker_image_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_image_pull () 
{ 
    case "$prev" in 
        --platform)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--all-tags -a --disable-content-trust=false --help --quiet -q";
            __docker_server_is_experimental && options+=" --platform";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag --platform);
            if [ "$cword" -eq "$counter" ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in 
                        --all-tags | -a)
                            __docker_complete_images --repo;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all-tags -a --disable-content-trust=false --help --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_remove () 
{ 
    _docker_image_rm
}
_docker_image_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_image_rmi () 
{ 
    _docker_image_rm
}
_docker_image_save () 
{ 
    case "$prev" in 
        --output | -o | ">")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --repo --tag --id
        ;;
    esac
}
_docker_image_tag () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_images () 
{ 
    _docker_image_ls
}
_docker_import () 
{ 
    _docker_image_import
}
_docker_info () 
{ 
    _docker_system_info
}
_docker_inspect () 
{ 
    local preselected_type;
    local type;
    if [ "$1" = "--type" ]; then
        preselected_type=yes;
        type="$2";
    else
        type=$(__docker_value_of_option --type);
    fi;
    case "$prev" in 
        --format | -f)
            return
        ;;
        --type)
            if [ -z "$preselected_type" ]; then
                COMPREPLY=($( compgen -W "container image network node plugin secret service volume" -- "$cur" ));
                return;
            fi
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format -f --help --size -s";
            if [ -z "$preselected_type" ]; then
                options+=" --type";
            fi;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            case "$type" in 
                '')
                    COMPREPLY=($( compgen -W "
						$(__docker_containers --all)
						$(__docker_images --force-tag --id)
						$(__docker_networks)
						$(__docker_nodes)
						$(__docker_plugins_installed)
						$(__docker_secrets)
						$(__docker_services)
						$(__docker_volumes)
					" -- "$cur" ));
                    __ltrim_colon_completions "$cur"
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images --force-tag --id
                ;;
                network)
                    __docker_complete_networks
                ;;
                node)
                    __docker_complete_nodes
                ;;
                plugin)
                    __docker_complete_plugins_installed
                ;;
                secret)
                    __docker_complete_secrets
                ;;
                service)
                    __docker_complete_services
                ;;
                volume)
                    __docker_complete_volumes
                ;;
            esac
        ;;
    esac
}
_docker_kill () 
{ 
    _docker_container_kill
}
_docker_load () 
{ 
    _docker_image_load
}
_docker_login () 
{ 
    case "$prev" in 
        --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --password -p --password-stdin --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs () 
{ 
    _docker_container_logs
}
_docker_manifest () 
{ 
    local subcommands="
		annotate
		create
		inspect
		push
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_manifest_annotate () 
{ 
    case "$prev" in 
        --arch)
            COMPREPLY=($( compgen -W "
				386
				amd64
				arm
				arm64
				mips64
				mips64le
				ppc64le
				riscv64
				s390x" -- "$cur" ));
            return
        ;;
        --os)
            COMPREPLY=($( compgen -W "
				darwin
				dragonfly
				freebsd
				linux
				netbsd
				openbsd
				plan9
				solaris
				windows" -- "$cur" ));
            return
        ;;
        --os-features | --variant)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--arch --help --os --os-features --variant" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "--arch|--os|--os-features|--variant" );
            if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--amend -a --help --insecure" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_manifest_inspect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --insecure --verbose -v" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --insecure --purge -p" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_network () 
{ 
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect () 
{ 
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	";
    local boolean_options="
		--help
	";
    case "$prev" in 
        --link)
            case "$cur" in 
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create () 
{ 
    case "$prev" in 
        --aux-address | --gateway | --ip-range | --ipam-opt | --ipv6 | --opt | -o | --subnet)
            return
        ;;
        --config-from)
            __docker_complete_networks;
            return
        ;;
        --driver | -d)
            __docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan;
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --label)
            return
        ;;
        --scope)
            COMPREPLY=($( compgen -W "local swarm" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--attachable --aux-address --config-from --config-only --driver -d --gateway --help --ingress --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --scope --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --verbose" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan;
            return
        ;;
        id)
            __docker_complete_networks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_networks --cur "${cur##*=}" --name;
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "global local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver id label name scope type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks --filter type=custom
        ;;
    esac
}
_docker_node () 
{ 
    local subcommands="
		demote
		inspect
		ls
		promote
		rm
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_node_demote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=manager
        ;;
    esac
}
_docker_node_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_list () 
{ 
    _docker_node_ls
}
_docker_node_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_nodes --cur "${cur##*=}" --id;
            return
        ;;
        label | node.label)
            return
        ;;
        membership)
            COMPREPLY=($( compgen -W "accepted pending" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_nodes --cur "${cur##*=}" --name;
            return
        ;;
        role)
            COMPREPLY=($( compgen -W "manager worker" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label membership name node.label role" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_node_promote () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=worker
        ;;
    esac
}
_docker_node_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_remove () 
{ 
    _docker_node_rm
}
_docker_node_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_node_update () 
{ 
    case "$prev" in 
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --role)
            COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            return
        ;;
        --label-add | --label-rm)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--availability|--label-add|--label-rm|--role');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_nodes;
            fi
        ;;
    esac
}
_docker_pause () 
{ 
    _docker_container_pause
}
_docker_plugin () 
{ 
    local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
		upgrade
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_create () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--compress --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir -d;
                fi;
            fi
        ;;
    esac
}
_docker_plugin_disable () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=true;
            fi
        ;;
    esac
}
_docker_plugin_enable () 
{ 
    case "$prev" in 
        --timeout)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --timeout" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--timeout');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=false;
            fi
        ;;
    esac
}
_docker_plugin_inspect () 
{ 
    case "$prev" in 
        --format | f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_install () 
{ 
    case "$prev" in 
        --alias)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--alias --disable --disable-content-trust=false --grant-all-permissions --help" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_list () 
{ 
    _docker_plugin_ls
}
_docker_plugin_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        capability)
            COMPREPLY=($( compgen -W "authz ipamdriver logdriver metricscollector networkdriver volumedriver" -- "${cur##*=}" ));
            return
        ;;
        enabled)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "capability enabled" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_push () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_remove () 
{ 
    _docker_plugin_rm
}
_docker_plugin_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_set () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_upgrade () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust --grant-all-permissions --help --skip-remote-check" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
                __ltrim_colon_completions "$cur";
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    local plugin_images="$(__docker_plugins_installed)";
                    COMPREPLY=($(compgen -S : -W "${plugin_images%:*}" -- "$cur"));
                    __docker_nospace;
                fi;
            fi
        ;;
    esac
}
_docker_port () 
{ 
    _docker_container_port
}
_docker_ps () 
{ 
    _docker_container_ls
}
_docker_pull () 
{ 
    _docker_image_pull
}
_docker_push () 
{ 
    _docker_image_push
}
_docker_rename () 
{ 
    _docker_container_rename
}
_docker_restart () 
{ 
    _docker_container_restart
}
_docker_rm () 
{ 
    _docker_container_rm
}
_docker_rmi () 
{ 
    _docker_image_rm
}
_docker_run () 
{ 
    _docker_container_run
}
_docker_save () 
{ 
    _docker_image_save
}
_docker_search () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        is-automated)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        is-official)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "is-automated is-official stars" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --limit --no-trunc" -- "$cur" ))
        ;;
    esac
}
_docker_secret () 
{ 
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_secret_create () 
{ 
    case "$prev" in 
        --driver | -d | --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--driver|-d|--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_secret_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_list () 
{ 
    _docker_secret_ls
}
_docker_secret_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_secrets --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_secrets --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_secret_remove () 
{ 
    _docker_secret_rm
}
_docker_secret_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_service () 
{ 
    local subcommands="
		create
		inspect
		logs
		ls
		rm
		rollback
		scale
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_service_create () 
{ 
    _docker_service_update_and_create
}
_docker_service_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_list () 
{ 
    _docker_service_ls
}
_docker_service_logs () 
{ 
    case "$prev" in 
        --since | --tail | -n)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --no-resolve --no-task-ids --no-trunc --raw --since --tail -n --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|-n');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services_and_tasks;
            fi
        ;;
    esac
}
_docker_service_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "global global-job replicated replicated-job" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "id label mode name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_service_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}" --add self;
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id name node" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_remove () 
{ 
    _docker_service_rm
}
_docker_service_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_rollback () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help --quit -q" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services;
            fi
        ;;
    esac
}
_docker_service_scale () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services;
            __docker_append_to_completions "=";
            __docker_nospace
        ;;
    esac
}
_docker_service_update () 
{ 
    _docker_service_update_and_create
}
_docker_service_update_and_create () 
{ 
    local options_with_args="
		--cap-add
		--cap-drop
		--endpoint-mode
		--entrypoint
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname
		--isolation
		--limit-cpu
		--limit-memory
		--limit-pids
		--log-driver
		--log-opt
		--max-replicas
		--replicas
		--replicas-max-per-node
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback-delay
		--rollback-failure-action
		--rollback-max-failure-ratio
		--rollback-monitor
		--rollback-order
		--rollback-parallelism
		--stop-grace-period
		--stop-signal
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-order
		--update-parallelism
		--user -u
		--workdir -w
	";
    __docker_server_os_is windows && options_with_args+="
		--credential-spec
	";
    local boolean_options="
		--detach -d
		--help
		--init
		--no-healthcheck
		--no-resolve-image
		--read-only
		--tty -t
		--with-registry-auth
	";
    __docker_complete_log_driver_options && return;
    if [ "$subcommand" = "create" ]; then
        options_with_args="$options_with_args
			--config
			--constraint
			--container-label
			--dns
			--dns-option
			--dns-search
			--env -e
			--env-file
			--generic-resource
			--group
			--host
			--label -l
			--mode
			--mount
			--name
			--network
			--placement-pref
			--publish -p
			--secret
			--sysctl
			--ulimit
		";
        case "$prev" in 
            --env-file)
                _filedir;
                return
            ;;
            --mode)
                COMPREPLY=($( compgen -W "global global-job replicated replicated-job" -- "$cur" ));
                return
            ;;
        esac;
    fi;
    if [ "$subcommand" = "update" ]; then
        options_with_args="$options_with_args
			--args
			--config-add
			--config-rm
			--constraint-add
			--constraint-rm
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--env-add
			--env-rm
			--generic-resource-add
			--generic-resource-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--label-add
			--label-rm
			--mount-add
			--mount-rm
			--network-add
			--network-rm
			--placement-pref-add
			--placement-pref-rm
			--publish-add
			--publish-rm
			--rollback
			--secret-add
			--secret-rm
			--sysctl-add
			--sysctl-rm
			--ulimit-add
			--ulimit-rm
		";
        boolean_options="$boolean_options
			--force
		";
        case "$prev" in 
            --env-rm)
                COMPREPLY=($( compgen -e -- "$cur" ));
                return
            ;;
            --image)
                __docker_complete_images --repo --tag --id;
                return
            ;;
        esac;
    fi;
    local strategy=$(__docker_map_key_of_current_option '--placement-pref|--placement-pref-add|--placement-pref-rm');
    case "$strategy" in 
        spread)
            COMPREPLY=($( compgen -W "engine.labels node.labels" -S . -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$prev" in 
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --config | --config-add | --config-rm)
            __docker_complete_configs;
            return
        ;;
        --endpoint-mode)
            COMPREPLY=($( compgen -W "dnsrr vip" -- "$cur" ));
            return
        ;;
        --env | -e | --env-add)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --group | --group-add | --group-rm)
            COMPREPLY=($(compgen -g -- "$cur"));
            return
        ;;
        --host | --host-add | --host-rm)
            case "$cur" in 
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network | --network-add | --network-rm)
            __docker_complete_networks;
            return
        ;;
        --placement-pref | --placement-pref-add | --placement-pref-rm)
            COMPREPLY=($( compgen -W "spread" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --restart-condition)
            COMPREPLY=($( compgen -W "any none on-failure" -- "$cur" ));
            return
        ;;
        --rollback-failure-action)
            COMPREPLY=($( compgen -W "continue pause" -- "$cur" ));
            return
        ;;
        --secret | --secret-add | --secret-rm)
            __docker_complete_secrets;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --update-failure-action)
            COMPREPLY=($( compgen -W "continue pause rollback" -- "$cur" ));
            return
        ;;
        --ulimit | --ulimit-add)
            __docker_complete_ulimits;
            return
        ;;
        --ulimit-rm)
            __docker_complete_ulimits --rm;
            return
        ;;
        --update-order | --rollback-order)
            COMPREPLY=($( compgen -W "start-first stop-first" -- "$cur" ));
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$subcommand" = "update" ]; then
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_services;
                fi;
            else
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_images --repo --tag --id;
                fi;
            fi
        ;;
    esac
}
_docker_stack () 
{ 
    local subcommands="
		deploy
		ls
		ps
		rm
		services
	";
    local aliases="
		down
		list
		remove
		up
	";
    __docker_complete_stack_orchestrator_options && return;
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_stack_deploy () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --compose-file | -c)
            _filedir yml;
            return
        ;;
        --resolve-image)
            COMPREPLY=($( compgen -W "always changed never" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--compose-file -c --help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            __docker_stack_orchestrator_is swarm && options+=" --prune --resolve-image --with-registry-auth";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--compose-file|-c|--kubeconfig|--namespace|--orchestrator|--resolve-image');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_down () 
{ 
    _docker_stack_rm
}
_docker_stack_list () 
{ 
    _docker_stack_ls
}
_docker_stack_ls () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format --help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_stack_ps () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        id)
            __docker_complete_stacks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_stacks --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name desired-state" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --no-resolve --no-trunc --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --all-namespaces --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--all-namespaces|--filter|-f|--format|--kubeconfig|--namespace');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_remove () 
{ 
    _docker_stack_rm
}
_docker_stack_rm () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$cur" in 
        -*)
            local options="--help --orchestrator";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_stacks
        ;;
    esac
}
_docker_stack_services () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        label)
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--filter -f --format --help --orchestrator --quiet -q";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig --namespace";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f|--format|--kubeconfig|--namespace|--orchestrator');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_up () 
{ 
    _docker_stack_deploy
}
_docker_start () 
{ 
    _docker_container_start
}
_docker_stats () 
{ 
    _docker_container_stats
}
_docker_stop () 
{ 
    _docker_container_stop
}
_docker_swarm () 
{ 
    local subcommands="
		ca
		init
		join
		join-token
		leave
		unlock
		unlock-key
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_ca () 
{ 
    case "$prev" in 
        --ca-cert | --ca-key)
            _filedir;
            return
        ;;
        --cert-expiry | --external-ca)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--ca-cert --ca-key --cert-expiry --detach -d --external-ca --help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_init () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --cert-expiry | --data-path-port | --default-addr-pool | --default-addr-pool-mask-length | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --autolock --availability --cert-expiry --data-path-addr --data-path-port --default-addr-pool --default-addr-pool-mask-length --dispatcher-heartbeat --external-ca --force-new-cluster --help --listen-addr --max-snapshots --snapshot-interval --task-history-limit " -- "$cur" ))
        ;;
    esac
}
_docker_swarm_join () 
{ 
    case "$prev" in 
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
        --token)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --availability --data-path-addr --help --listen-addr --token" -- "$cur" ))
        ;;
        *:)
            COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ))
        ;;
    esac
}
_docker_swarm_join_token () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_swarm_leave () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock_key () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_update () 
{ 
    case "$prev" in 
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--autolock --cert-expiry --dispatcher-heartbeat --external-ca --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_system () 
{ 
    local subcommands="
		df
		events
		info
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_system_df () 
{ 
    case "$prev" in 
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format --help --verbose -v" -- "$cur" ))
        ;;
    esac
}
_docker_system_events () 
{ 
    local key=$(__docker_map_key_of_current_option '-f|--filter');
    case "$key" in 
        container)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        daemon)
            local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p');
            COMPREPLY=($( compgen -W "$name" -- "${cur##*=}" ));
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disable
				disconnect
				enable
				exec_create
				exec_detach
				exec_die
				exec_start
				export
				health_status
				import
				install
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				remove
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}";
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "config container daemon image network node plugin secret service volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container daemon event image label network node scope type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until --format" -- "$cur" ))
        ;;
    esac
}
_docker_system_info () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_system_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help --volumes" -- "$cur" ))
        ;;
    esac
}
_docker_tag () 
{ 
    _docker_image_tag
}
_docker_top () 
{ 
    _docker_container_top
}
_docker_trust () 
{ 
    local subcommands="
		inspect
		revoke
		sign
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_trust_inspect () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --pretty" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_revoke () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --yes -y" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_sign () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help --local" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_unpause () 
{ 
    _docker_container_unpause
}
_docker_update () 
{ 
    _docker_container_update
}
_docker_version () 
{ 
    __docker_complete_stack_orchestrator_options && return;
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            local options="--format -f --help";
            __docker_stack_orchestrator_is kubernetes && options+=" --kubeconfig";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
    esac
}
_docker_volume () 
{ 
    local subcommands="
		create
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create () 
{ 
    case "$prev" in 
        --driver | -d)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --label | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect () 
{ 
    case "$prev" in 
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_list () 
{ 
    _docker_volume_ls
}
_docker_volume_ls () 
{ 
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in 
        dangling)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume;
            return
        ;;
        name)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in 
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_prune () 
{ 
    case "$prev" in 
        --filter)
            COMPREPLY=($( compgen -W "label label!" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--filter --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume_remove () 
{ 
    _docker_volume_rm
}
_docker_volume_rm () 
{ 
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait () 
{ 
    _docker_container_wait
}
_dvd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}"))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        __expand_tilde_by_ref cur;
    else
        if [[ "$cur" == \~* ]]; then
            _tilde "$cur" || eval COMPREPLY[0]=$(printf ~%q "${COMPREPLY[0]#\~}");
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local IFS='
';
    _tilde "$cur" || return;
    local -a toks;
    local reset;
    if [[ "$1" == -d ]]; then
        reset=$(shopt -po noglob);
        set -o noglob;
        toks=($(compgen -d -- "$cur"));
        IFS=' ';
        $reset;
        IFS='
';
    else
        local quoted;
        _quote_readline_by_ref "$cur" quoted;
        local xspec=${1:+"!*.@($1|${1^^})"} plusdirs=();
        local opts=(-f -X "$xspec");
        [[ -n $xspec ]] && plusdirs=(-o plusdirs);
        [[ -n ${COMP_FILEDIR_FALLBACK-} ]] || opts+=("${plusdirs[@]}");
        reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen "${opts[@]}" -- $quoted));
        IFS=' ';
        $reset;
        IFS='
';
        [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && ${#toks[@]} -lt 1 ]] && { 
            reset=$(shopt -po noglob);
            set -o noglob;
            toks+=($(compgen -f "${plusdirs[@]}" -- $quoted));
            IFS=' ';
            $reset;
            IFS='
'
        };
    fi;
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "'!$xspec'" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && ${#toks[@]} -lt 1 ]] && { 
        local reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen -f -- "$(quote_readline "$cur")"));
        IFS=' ';
        $reset;
        IFS='
'
    };
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$(cut -d'	' -f2 /proc/filesystems)
             $(awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null)";
    else
        fss="$(awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null)
             $(awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null)
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($(compgen -W "$fss" -- "$cur"))
}
_fzf_alias_completion () 
{ 
    _fzf_complete -m -- "$@" < <(
    alias | sed 's/=.*//' | sed 's/.* //'
  )
}
_fzf_compgen_dir () 
{ 
    command find -L "$1" -name .git -prune -o -name .hg -prune -o -name .svn -prune -o -type d -a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}
_fzf_compgen_path () 
{ 
    echo "$1";
    command find -L "$1" -name .git -prune -o -name .hg -prune -o -name .svn -prune -o \( -type d -o -type f -o -type l \) -a -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
}
_fzf_complete () 
{ 
    local args rest str_arg i sep;
    args=("$@");
    sep=;
    for i in "${!args[@]}";
    do
        if [[ "${args[$i]}" = -- ]]; then
            sep=$i;
            break;
        fi;
    done;
    if [[ -n "$sep" ]]; then
        str_arg=;
        rest=("${args[@]:$((sep + 1)):${#args[@]}}");
        args=("${args[@]:0:$sep}");
    else
        str_arg=$1;
        args=();
        shift;
        rest=("$@");
    fi;
    local cur selected trigger cmd post;
    post="$(caller 0 | awk '{print $2}')_post";
    type -t "$post" > /dev/null 2>&1 || post=cat;
    cmd="${COMP_WORDS[0]//[^A-Za-z0-9_=]/_}";
    trigger=${FZF_COMPLETION_TRIGGER-'**'};
    cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ "$cur" == *"$trigger" ]]; then
        cur=${cur:0:${#cur}-${#trigger}};
        selected=$(FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse --bind=ctrl-z:ignore $FZF_DEFAULT_OPTS $FZF_COMPLETION_OPTS $str_arg" __fzf_comprun "${rest[0]}" "${args[@]}" -q "$cur" | $post | tr '\n' ' ');
        selected=${selected% };
        if [[ -n "$selected" ]]; then
            COMPREPLY=("$selected");
        else
            COMPREPLY=("$cur");
        fi;
        printf '\e[5n';
        return 0;
    else
        _fzf_handle_dynamic_completion "$cmd" "${rest[@]}";
    fi
}
_fzf_complete_kill () 
{ 
    local trigger=${FZF_COMPLETION_TRIGGER-'**'};
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ -z "$cur" ]]; then
        COMP_WORDS[$COMP_CWORD]=$trigger;
    else
        if [[ "$cur" != *"$trigger" ]]; then
            return 1;
        fi;
    fi;
    _fzf_proc_completion "$@"
}
_fzf_dir_completion () 
{ 
    __fzf_generic_path_completion _fzf_compgen_dir "" "/" "$@"
}
_fzf_file_completion () 
{ 
    _fzf_path_completion "$@"
}
_fzf_handle_dynamic_completion () 
{ 
    local cmd orig_var orig ret orig_cmd orig_complete;
    cmd="$1";
    shift;
    orig_cmd="$1";
    orig_var="_fzf_orig_completion_$cmd";
    orig="${!orig_var##*#}";
    if [[ -n "$orig" ]] && type "$orig" > /dev/null 2>&1; then
        $orig "$@";
    else
        if [[ -n "$_fzf_completion_loader" ]]; then
            orig_complete=$(complete -p "$orig_cmd" 2> /dev/null);
            _completion_loader "$@";
            ret=$?;
            if [[ "$(complete -p "$orig_cmd" 2> /dev/null)" != "$orig_complete" ]]; then
                __fzf_orig_completion < <(complete -p "$orig_cmd" 2> /dev/null);
                if [[ "$__fzf_nospace_commands" = *" $orig_cmd "* ]]; then
                    eval "${orig_complete/ -F / -o nospace -F }";
                else
                    eval "$orig_complete";
                fi;
            fi;
            return $ret;
        fi;
    fi
}
_fzf_host_completion () 
{ 
    _fzf_complete +m -- "$@" < <(
    command cat <(command tail -n +1 ~/.ssh/config ~/.ssh/config.d/* /etc/ssh/ssh_config 2> /dev/null | command grep -i '^\s*host\(name\)\? ' | awk '{for (i = 2; i <= NF; i++) print $1 " " $i}' | command grep -v '[*?]')         <(command grep -oE '^[[a-z0-9.,:-]+' ~/.ssh/known_hosts | tr ',' '\n' | tr -d '[' | awk '{ print $1 " " $1 }')         <(command grep -v '^\s*\(#\|$\)' /etc/hosts | command grep -Fv '0.0.0.0') |
        awk '{if (length($2) > 0) {print $2}}' | sort -u
  )
}
_fzf_opts_completion () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="
    -x --extended
    -e --exact
    --algo
    -i +i
    -n --nth
    --with-nth
    -d --delimiter
    +s --no-sort
    --tac
    --tiebreak
    -m --multi
    --no-mouse
    --bind
    --cycle
    --no-hscroll
    --jump-labels
    --height
    --literal
    --reverse
    --margin
    --inline-info
    --prompt
    --pointer
    --marker
    --header
    --header-lines
    --ansi
    --tabstop
    --color
    --no-bold
    --history
    --history-size
    --preview
    --preview-window
    -q --query
    -1 --select-1
    -0 --exit-0
    -f --filter
    --print-query
    --expect
    --sync";
    case "${prev}" in 
        --tiebreak)
            COMPREPLY=($(compgen -W "length begin end index" -- "$cur"));
            return 0
        ;;
        --color)
            COMPREPLY=($(compgen -W "dark light 16 bw" -- "$cur"));
            return 0
        ;;
        --history)
            COMPREPLY=();
            return 0
        ;;
    esac;
    if [[ "$cur" =~ ^-|\+ ]]; then
        COMPREPLY=($(compgen -W "${opts}" -- "$cur"));
        return 0;
    fi;
    return 0
}
_fzf_path_completion () 
{ 
    __fzf_generic_path_completion _fzf_compgen_path "-m" "" "$@"
}
_fzf_proc_completion () 
{ 
    _fzf_complete -m --preview 'echo {}' --preview-window down:3:wrap --min-height 15 -- "$@" < <(
    command ps -ef | sed 1d
  )
}
_fzf_proc_completion_post () 
{ 
    awk '{print $2}'
}
_fzf_setup_completion () 
{ 
    local kind fn cmd;
    kind=$1;
    fn=_fzf_${1}_completion;
    if [[ $# -lt 2 ]] || ! type -t "$fn" > /dev/null; then
        echo "usage: ${FUNCNAME[0]} path|dir|var|alias|host|proc COMMANDS...";
        return 1;
    fi;
    shift;
    __fzf_orig_completion < <(complete -p "$@" 2> /dev/null);
    for cmd in "$@";
    do
        case "$kind" in 
            dir)
                __fzf_defc "$cmd" "$fn" "-o nospace -o dirnames"
            ;;
            var)
                __fzf_defc "$cmd" "$fn" "-o default -o nospace -v"
            ;;
            alias)
                __fzf_defc "$cmd" "$fn" "-a"
            ;;
            *)
                __fzf_defc "$cmd" "$fn" "-o default -o bashdefault"
            ;;
        esac;
    done
}
_fzf_var_completion () 
{ 
    _fzf_complete -m -- "$@" < <(
    declare -xp | sed 's/=.*//' | sed 's/.* //'
  )
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        (( OPTIND += 1 ));
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    [[ $index -gt 0 ]] && ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    (( index -= old_size - new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_examples () 
{ 
    local manifest=$(_locate_manifest);
    [ -z "$manifest" ] && return 0;
    local files=("${manifest%/*}"/examples/*.rs);
    local names=("${files[@]##*/}");
    local names=("${names[@]%.*}");
    if [[ "${names[@]}" != "*" ]]; then
        echo "${names[@]}";
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_names_from_array () 
{ 
    local manifest=$(_locate_manifest);
    if [[ -z $manifest ]]; then
        return 0;
    fi;
    local last_line;
    local -a names;
    local in_block=false;
    local block_name=$1;
    while read line; do
        if [[ $last_line == "[[$block_name]]" ]]; then
            in_block=true;
        else
            if [[ $last_line =~ .*\[\[.* ]]; then
                in_block=false;
            fi;
        fi;
        if [[ $in_block == true ]]; then
            if [[ $line =~ .*name.*\= ]]; then
                line=${line##*=};
                line=${line%%\"};
                line=${line##*\"};
                names+=($line);
            fi;
        fi;
        last_line=$line;
    done < $manifest;
    echo "${names[@]}"
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_get_targets () 
{ 
    local result=();
    local targets=$(rustup target list);
    while read line; do
        if [[ "$line" =~ default|installed ]]; then
            result+=("${line%% *}");
        fi;
    done <<< "$targets";
    echo "${result[@]}"
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent group | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/group)' -- "$cur"));
        fi;
    fi
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_included_ssh_config_files () 
{ 
    [[ $# -lt 1 ]] && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i f;
    configfile=$1;
    local included=($(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\{1,\}\([^#%]*\)\(#.*\)\{0,1\}$/\1/p' "${configfile}"));
    for i in "${included[@]}";
    do
        if ! [[ "$i" =~ ^\~.*|^\/.* ]]; then
            if [[ "$configfile" =~ ^\/etc\/ssh.* ]]; then
                i="/etc/ssh/$i";
            else
                i="$HOME/.ssh/$i";
            fi;
        fi;
        __expand_tilde_by_ref i;
        for f in ${i};
        do
            if [ -r $f ]; then
                config+=("$f");
                _included_ssh_config_files $f;
            fi;
        done;
    done
}
_init_completion () 
{ 
    local exclude="" flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && (( cword -= skip ));
        else
            (( i++ ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($(compgen -W "$(PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}')" -- "$1"))
}
_ip_addresses () 
{ 
    local n;
    case $1 in 
        -a)
            n='6\?'
        ;;
        -6)
            n='6'
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs=$({ LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
        command sed -e 's/[[:space:]]addr:/ /' -ne             "s|.*inet${n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p");
    COMPREPLY+=($(compgen -W "$addrs" -- "$cur"))
}
_kernel_versions () 
{ 
    COMPREPLY=($(compgen -W '$(command ls /lib/modules)' -- "$cur"))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix OIFS=$IFS;
    local cur user suffix aliases i host ipv4 ipv6;
    local -a kh tmpkh khd config;
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=1
            ;;
            6)
                ipv6=1
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
    cur=${!OPTIND};
    (( OPTIND += 1 ));
    [[ $# -ge $OPTIND ]] && echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done) 1>&2;
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    for i in "${config[@]}";
    do
        _included_ssh_config_files "$i";
    done;
    if [[ ${#config[@]} -gt 0 ]]; then
        local IFS='
' j;
        tmpkh=($(awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        if [[ ${#kh[@]} -gt 0 ]]; then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    set -- "${tmpkh[@]}";
                    [[ $1 == [\|\#]* ]] && continue;
                    [[ $1 == @* ]] && shift;
                    local IFS=,;
                    for host in $1;
                    do
                        [[ $host == *[*?]* ]] && continue;
                        host="${host#[}";
                        host="${host%]?(:+([0-9]))}";
                        COMPREPLY+=($host);
                    done;
                    IFS=$OIFS;
                done < "$i";
            done;
            COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$cur*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]]\{1,\}\([^#*?%]*\)\(#.*\)\{0,1\}$/\1/p' "${config[@]}");
        COMPREPLY+=($(compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur"));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && type avahi-browse &> /dev/null; then
        COMPREPLY+=($(compgen -P "$prefix$user" -S "$suffix" -W             "$(avahi-browse -cpr _workstation._tcp 2>/dev/null |                awk -F';' '/^=/ { print $7 }' | sort -u)" -- "$cur"));
    fi;
    COMPREPLY+=($(compgen -W         "$(ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }')"         -- "$cur"));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($(compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur"));
    fi;
    if [[ -n $ipv4 ]]; then
        COMPREPLY=("${COMPREPLY[@]/*:*$suffix/}");
    fi;
    if [[ -n $ipv6 ]]; then
        COMPREPLY=("${COMPREPLY[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -n $ipv4 || -n $ipv6 ]]; then
        for i in "${!COMPREPLY[@]}";
        do
            [[ -n ${COMPREPLY[i]} ]] || unset -v COMPREPLY[i];
        done;
    fi;
    __ltrim_colon_completions "$prefix$user$cur"
}
_locate_manifest () 
{ 
    cargo locate-project --message-format plain 2> /dev/null
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return
                ;;
                *file* | *path*)
                    _filedir;
                    return
                ;;
            esac
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$(LC_ALL=C $1 --help 2>&1 |             while read -r line; do                 [[ $line =~ --[-A-Za-z0-9]+=? ]] &&                     printf '%s\n' ${BASH_REMATCH[0]}
            done)" -- "$cur"));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == *@(rmdir|chroot) ]]; then
            _filedir -d;
        else
            [[ "$1" == *mkdir ]] && compopt -o nospace;
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(        { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($({ arp -an || ip neigh show; } 2>/dev/null | command sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p"));
    COMPREPLY+=($(command sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($(compgen -W "$(command ls -RL $modpath 2>/dev/null |         command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p')" -- "$cur"))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$(getconf $var 2>/dev/null);
    printf %s ${n:-1}
}
_node_complete () 
{ 
    local cur_word options;
    cur_word="${COMP_WORDS[COMP_CWORD]}";
    if [[ "${cur_word}" == -* ]]; then
        COMPREPLY=($(compgen -W '--icu-data-dir --title --trace-event-categories --trace-tls --experimental-import-meta-resolve --fast_calls_with_arguments_mismatches --use-largepages --trace-event-file-pattern --disable-proto --experimental-worker --security-revert --completion-bash --debug-arraybuffer-allocations --max-http-header-size --v8-pool-size --tls-max-v1.2 --zero-fill-buffers --trace-sync-io --disallow-code-generation-from-strings --force-context-aware --help --pending-deprecation --version --use-bundled-ca --v8-options --report-filename --cpu-prof-interval --report-compact --interpreted-frames-native-stack --report-directory --report-on-fatalerror --perf-prof --report-signal --preserve-symlinks-main --test-udp-no-try-send --openssl-config --harmony_numeric_separator --tls-cipher-list --use-openssl-ca --trace-sigint --no-node-snapshot --debug --track-heap-objects --experimental-repl-await --experimental-json-modules --perf-prof-unwinding-info --abort-on-uncaught-exception --perf-basic-prof-only-functions --max-old-space-size --perf-basic-prof --stack-trace-limit --jitless --require --huge-max-old-generation-size --report-uncaught-exception --report-on-signal --experimental-policy --debug-brk --enable-source-maps --experimental-loader --tls-min-v1.2 --experimental-modules --experimental-wasm-modules --policy-integrity --cpu-prof-name --experimental-vm-modules --cpu-prof --experimental-report --experimental-wasi-unstable-preview1 --eval --expose-internals --trace-uncaught --insecure-http-parser --frozen-intrinsics --tls-keylog --input-type --heapsnapshot-signal --tls-max-v1.3 --http-parser --http-server-default-timeout --experimental-specifier-resolution --es-module-specifier-resolution --no-deprecation --tls-min-v1.0 --no-force-async-hooks-checks --no-warnings --heap-prof-name --heap-prof-dir --preserve-symlinks --prof-process --tls-min-v1.1 --inspect-port --cpu-prof-dir --trace-exit --heap-prof --heap-prof-interval --redirect-warnings --tls-min-v1.3 --throw-deprecation --trace-deprecation --trace-warnings --unhandled-rejections --check --print --inspect --interactive --napi-modules --inspect-brk --inspect-brk-node --inspect-publish-uid -v --debug-port --trace-events-enabled --security-reverts -h --print <arg> --prof-process --inspect= --loader -c --debug-brk= -e -pe -p -r -i --inspect-brk= --debug= --inspect-brk-node=' -- "${cur_word}"));
        return 0;
    else
        COMPREPLY=($(compgen -f "${cur_word}"));
        return 0;
    fi
}
_pandoc () 
{ 
    local cur prev opts lastc informats outformats highlight_styles datafiles;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="-f -r --from --read -t -w --to --write -o --output --data-dir -M --metadata --metadata-file -d --defaults --file-scope --sandbox -s --standalone --template -V --variable --wrap --ascii --toc --table-of-contents --toc-depth -N --number-sections --number-offset --top-level-division --extract-media --resource-path -H --include-in-header -B --include-before-body -A --include-after-body --no-highlight --highlight-style --syntax-definition --dpi --eol --columns -p --preserve-tabs --tab-stop --pdf-engine --pdf-engine-opt --reference-doc --self-contained --request-header --no-check-certificate --abbreviations --indented-code-classes --default-image-extension -F --filter -L --lua-filter --shift-heading-level-by --base-header-level --strip-empty-paragraphs --track-changes --strip-comments --reference-links --reference-location --atx-headers --markdown-headings --listings -i --incremental --slide-level --section-divs --html-q-tags --email-obfuscation --id-prefix -T --title-prefix -c --css --epub-subdirectory --epub-cover-image --epub-metadata --epub-embed-font --epub-chapter-level --ipynb-output -C --citeproc --bibliography --csl --citation-abbreviations --natbib --biblatex --mathml --webtex --mathjax --katex --gladtex --trace --dump-args --ignore-args --verbose --quiet --fail-if-warnings --log --bash-completion --list-input-formats --list-output-formats --list-extensions --list-highlight-languages --list-highlight-styles -D --print-default-template --print-default-data-file --print-highlight-style -v --version -h --help";
    informats="biblatex bibtex commonmark commonmark_x creole csljson csv docbook docx dokuwiki epub fb2 gfm haddock html ipynb jats jira json latex man markdown markdown_github markdown_mmd markdown_phpextra markdown_strict mediawiki muse native odt opml org rst rtf t2t textile tikiwiki twiki vimwiki";
    outformats="asciidoc asciidoctor beamer biblatex bibtex commonmark commonmark_x context csljson docbook docbook4 docbook5 docx dokuwiki dzslides epub epub2 epub3 fb2 gfm haddock html html4 html5 icml ipynb jats jats_archiving jats_articleauthoring jats_publishing jira json latex man markdown markdown_github markdown_mmd markdown_phpextra markdown_strict markua mediawiki ms muse native odt opendocument opml org pdf plain pptx revealjs rst rtf s5 slideous slidy tei texinfo textile xwiki zimwiki";
    highlight_styles="pygments tango espresso zenburn kate monochrome breezedark haddock";
    datafiles="reference.docx reference.odt reference.pptx MANUAL.txt docx/_rels/.rels pptx/_rels/.rels abbreviations bash_completion.tpl creole.lua default.csl docx/[Content_Types].xml docx/docProps/app.xml docx/docProps/core.xml docx/docProps/custom.xml docx/word/_rels/document.xml.rels docx/word/_rels/footnotes.xml.rels docx/word/comments.xml docx/word/document.xml docx/word/fontTable.xml docx/word/footnotes.xml docx/word/numbering.xml docx/word/settings.xml docx/word/styles.xml docx/word/theme/theme1.xml docx/word/webSettings.xml dzslides/template.html epub.css init.lua odt/Configurations2/accelerator/current.xml odt/META-INF/manifest.xml odt/Thumbnails/thumbnail.png odt/content.xml odt/manifest.rdf odt/meta.xml odt/mimetype odt/settings.xml odt/styles.xml pptx/[Content_Types].xml pptx/docProps/app.xml pptx/docProps/core.xml pptx/ppt/_rels/presentation.xml.rels pptx/ppt/notesMasters/_rels/notesMaster1.xml.rels pptx/ppt/notesMasters/notesMaster1.xml pptx/ppt/notesSlides/_rels/notesSlide1.xml.rels pptx/ppt/notesSlides/_rels/notesSlide2.xml.rels pptx/ppt/notesSlides/notesSlide1.xml pptx/ppt/notesSlides/notesSlide2.xml pptx/ppt/presProps.xml pptx/ppt/presentation.xml pptx/ppt/slideLayouts/_rels/slideLayout1.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout10.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout11.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout2.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout3.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout4.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout5.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout6.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout7.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout8.xml.rels pptx/ppt/slideLayouts/_rels/slideLayout9.xml.rels pptx/ppt/slideLayouts/slideLayout1.xml pptx/ppt/slideLayouts/slideLayout10.xml pptx/ppt/slideLayouts/slideLayout11.xml pptx/ppt/slideLayouts/slideLayout2.xml pptx/ppt/slideLayouts/slideLayout3.xml pptx/ppt/slideLayouts/slideLayout4.xml pptx/ppt/slideLayouts/slideLayout5.xml pptx/ppt/slideLayouts/slideLayout6.xml pptx/ppt/slideLayouts/slideLayout7.xml pptx/ppt/slideLayouts/slideLayout8.xml pptx/ppt/slideLayouts/slideLayout9.xml pptx/ppt/slideMasters/_rels/slideMaster1.xml.rels pptx/ppt/slideMasters/slideMaster1.xml pptx/ppt/slides/_rels/slide1.xml.rels pptx/ppt/slides/_rels/slide2.xml.rels pptx/ppt/slides/_rels/slide3.xml.rels pptx/ppt/slides/_rels/slide4.xml.rels pptx/ppt/slides/slide1.xml pptx/ppt/slides/slide2.xml pptx/ppt/slides/slide3.xml pptx/ppt/slides/slide4.xml pptx/ppt/tableStyles.xml pptx/ppt/theme/theme1.xml pptx/ppt/theme/theme2.xml pptx/ppt/viewProps.xml sample.lua templates/affiliations.jats templates/article.jats_publishing templates/default.asciidoc templates/default.asciidoctor templates/default.biblatex templates/default.bibtex templates/default.commonmark templates/default.context templates/default.docbook4 templates/default.docbook5 templates/default.dokuwiki templates/default.dzslides templates/default.epub2 templates/default.epub3 templates/default.haddock templates/default.html4 templates/default.html5 templates/default.icml templates/default.jats_archiving templates/default.jats_articleauthoring templates/default.jats_publishing templates/default.jira templates/default.latex templates/default.man templates/default.markdown templates/default.markua templates/default.mediawiki templates/default.ms templates/default.muse templates/default.opendocument templates/default.opml templates/default.org templates/default.plain templates/default.revealjs templates/default.rst templates/default.rtf templates/default.s5 templates/default.slideous templates/default.slidy templates/default.tei templates/default.texinfo templates/default.textile templates/default.xwiki templates/default.zimwiki templates/styles.html translations/am.yaml translations/ar.yaml translations/bg.yaml translations/bn.yaml translations/ca.yaml translations/cs.yaml translations/da.yaml translations/de.yaml translations/el.yaml translations/en.yaml translations/eo.yaml translations/es.yaml translations/et.yaml translations/eu.yaml translations/fa.yaml translations/fi.yaml translations/fr.yaml translations/he.yaml translations/hi.yaml translations/hr.yaml translations/hu.yaml translations/is.yaml translations/it.yaml translations/km.yaml translations/ko.yaml translations/lo.yaml translations/lt.yaml translations/lv.yaml translations/nl.yaml translations/no.yaml translations/pl.yaml translations/pt.yaml translations/rm.yaml translations/ro.yaml translations/ru.yaml translations/sk.yaml translations/sl.yaml translations/sq.yaml translations/sr-cyrl.yaml translations/sr.yaml translations/sv.yaml translations/th.yaml translations/tr.yaml translations/uk.yaml translations/ur.yaml translations/vi.yaml translations/zh-Hans.yaml translations/zh-Hant.yaml";
    case "${prev}" in 
        --from | -f | --read | -r)
            COMPREPLY=($(compgen -W "${informats}" -- ${cur}));
            return 0
        ;;
        --to | -t | --write | -w | -D | --print-default-template)
            COMPREPLY=($(compgen -W "${outformats}" -- ${cur}));
            return 0
        ;;
        --email-obfuscation)
            COMPREPLY=($(compgen -W "references javascript none" -- ${cur}));
            return 0
        ;;
        --ipynb-output)
            COMPREPLY=($(compgen -W "all none best" -- ${cur}));
            return 0
        ;;
        --pdf-engine)
            COMPREPLY=($(compgen -W "pdflatex lualatex xelatex latexmk tectonic wkhtmltopdf weasyprint prince context pdfroff" -- ${cur}));
            return 0
        ;;
        --print-default-data-file)
            COMPREPLY=($(compgen -W "${datafiles}" -- ${cur}));
            return 0
        ;;
        --wrap)
            COMPREPLY=($(compgen -W "auto none preserve" -- ${cur}));
            return 0
        ;;
        --track-changes)
            COMPREPLY=($(compgen -W "accept reject all" -- ${cur}));
            return 0
        ;;
        --reference-location)
            COMPREPLY=($(compgen -W "block section document" -- ${cur}));
            return 0
        ;;
        --top-level-division)
            COMPREPLY=($(compgen -W "section chapter part" -- ${cur}));
            return 0
        ;;
        --highlight-style | --print-highlight-style)
            COMPREPLY=($(compgen -W "${highlight_styles}" -- ${cur}));
            return 0
        ;;
        --eol)
            COMPREPLY=($(compgen -W "crlf lf native" -- ${cur}));
            return 0
        ;;
        --markdown-headings)
            COMPREPLY=($(compgen -W "setext atx" -- ${cur}));
            return 0
        ;;
        *)

        ;;
    esac;
    case "${cur}" in 
        -*)
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
            return 0
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -X '' -f "${cur}"));
            return 0
        ;;
    esac
}
_parse_help () 
{ 
    eval local cmd=$(quote "$1");
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([[:blank:]])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$(quote "$1");
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pci_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur"))
}
_pgids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pgid=)' -- "$cur"))
}
_pids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pid=)' -- "$cur"))
}
_pnames () 
{ 
    local -a procs;
    if [[ "$1" == -s ]]; then
        procs=($(command ps axo comm | command sed -e 1d));
    else
        local line i=-1 OIFS=$IFS;
        IFS='
';
        local -a psout=($(command ps axo command=));
        IFS=$OIFS;
        for line in "${psout[@]}";
        do
            if [[ $i -eq -1 ]]; then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:$i};
                line=${line%% *};
                procs+=($line);
            fi;
        done;
        if [[ $i -eq -1 ]]; then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=(${BASH_REMATCH[1]});
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    procs+=($line);
                fi;
            done;
        fi;
    fi;
    COMPREPLY=($(compgen -X "<defunct>" -W '${procs[@]}' -- "$cur" ))
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_rbenv () 
{ 
    COMPREPLY=();
    local word="${COMP_WORDS[COMP_CWORD]}";
    if [ "$COMP_CWORD" -eq 1 ]; then
        COMPREPLY=($(compgen -W "$(rbenv commands)" -- "$word"));
    else
        local words=("${COMP_WORDS[@]}");
        unset "words[0]";
        unset "words[$COMP_CWORD]";
        local completions=$(rbenv completions "${words[@]}");
        COMPREPLY=($(compgen -W "$completions" -- "$word"));
    fi
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$(bind -v)" == *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_rustup () 
{ 
    local i cur prev opts cmds;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmd="";
    opts="";
    for i in ${COMP_WORDS[@]};
    do
        case "${i}" in 
            rustup)
                cmd="rustup"
            ;;
            active-toolchain)
                cmd+="__active__toolchain"
            ;;
            add)
                cmd+="__add"
            ;;
            auto-self-update)
                cmd+="__auto__self__update"
            ;;
            check)
                cmd+="__check"
            ;;
            completions)
                cmd+="__completions"
            ;;
            component)
                cmd+="__component"
            ;;
            default)
                cmd+="__default"
            ;;
            default-host)
                cmd+="__default__host"
            ;;
            doc)
                cmd+="__doc"
            ;;
            docs)
                cmd+="__docs"
            ;;
            dump-testament)
                cmd+="__dump__testament"
            ;;
            help)
                cmd+="__help"
            ;;
            home)
                cmd+="__home"
            ;;
            install)
                cmd+="__install"
            ;;
            keys)
                cmd+="__keys"
            ;;
            link)
                cmd+="__link"
            ;;
            list)
                cmd+="__list"
            ;;
            man)
                cmd+="__man"
            ;;
            override)
                cmd+="__override"
            ;;
            profile)
                cmd+="__profile"
            ;;
            remove)
                cmd+="__remove"
            ;;
            run)
                cmd+="__run"
            ;;
            self)
                cmd+="__self"
            ;;
            set)
                cmd+="__set"
            ;;
            show)
                cmd+="__show"
            ;;
            target)
                cmd+="__target"
            ;;
            toolchain)
                cmd+="__toolchain"
            ;;
            uninstall)
                cmd+="__uninstall"
            ;;
            unset)
                cmd+="__unset"
            ;;
            update)
                cmd+="__update"
            ;;
            upgrade)
                cmd+="__upgrade"
            ;;
            upgrade-data)
                cmd+="__upgrade__data"
            ;;
            which)
                cmd+="__which"
            ;;
            *)

            ;;
        esac;
    done;
    case "${cmd}" in 
        rustup)
            opts=" -v -q -h -V  --verbose --quiet --help --version  <+toolchain>  dump-testament show install uninstall update check default toolchain target component override run which doc man self set completions help  upgrade  docs";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__check)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__completions)
            opts=" -h -V  --help --version  <shell> <command> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__component)
            opts=" -h -V  --help --version   list add remove help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__component__add)
            opts=" -h -V  --help --version --toolchain --target  <component>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__component__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__component__list)
            opts=" -h -V  --installed --help --version --toolchain  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__component__remove)
            opts=" -h -V  --help --version --toolchain --target  <component>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__default)
            opts=" -h -V  --help --version  <toolchain> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__doc)
            opts=" -h -V  --path --alloc --book --cargo --core --edition-guide --nomicon --proc_macro --reference --rust-by-example --rustc --rustdoc --std --test --unstable-book --embedded-book --help --version --toolchain  <topic> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__docs)
            opts=" -h -V  --path --alloc --book --cargo --core --edition-guide --nomicon --proc_macro --reference --rust-by-example --rustc --rustdoc --std --test --unstable-book --embedded-book --help --version --toolchain  <topic> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__dump__testament)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__install)
            opts=" -h -V  --no-self-update --force --help --version --profile  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --profile)
                    COMPREPLY=($(compgen -W "minimal default complete" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__man)
            opts=" -h -V  --help --version --toolchain  <command> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override)
            opts=" -h -V  --help --version   list set unset help  add  remove";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__add)
            opts=" -h -V  --help --version --path  <toolchain> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__list)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__remove)
            opts=" -h -V  --nonexistent --help --version --path  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__set)
            opts=" -h -V  --help --version --path  <toolchain> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__override__unset)
            opts=" -h -V  --nonexistent --help --version --path  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__run)
            opts=" -h -V  --install --help --version  <toolchain> <command>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__self)
            opts=" -h -V  --help --version   update uninstall upgrade-data help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__self__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__self__uninstall)
            opts=" -y -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__self__update)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__self__upgrade__data)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__set)
            opts=" -h -V  --help --version   default-host profile auto-self-update help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__set__auto__self__update)
            opts=" -h -V  --help --version  <auto-self-update-mode> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__set__default__host)
            opts=" -h -V  --help --version  <host_triple> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__set__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__set__profile)
            opts=" -h -V  --help --version  <profile-name> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show)
            opts=" -h -V  --help --version   active-toolchain home profile keys help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show__active__toolchain)
            opts=" -v -h -V  --verbose --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show__home)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show__keys)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__show__profile)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target)
            opts=" -h -V  --help --version   list add remove help  install  uninstall";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__add)
            opts=" -h -V  --help --version --toolchain  <target>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__install)
            opts=" -h -V  --help --version --toolchain  <target>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__list)
            opts=" -h -V  --installed --help --version --toolchain  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__remove)
            opts=" -h -V  --help --version --toolchain  <target>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__target__uninstall)
            opts=" -h -V  --help --version --toolchain  <target>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain)
            opts=" -h -V  --help --version   list install uninstall link help  update add  remove";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__add)
            opts=" -h -V -c -t  --no-self-update --force --allow-downgrade --help --version --profile --component --target  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --profile)
                    COMPREPLY=($(compgen -W "minimal default complete" -- "${cur}"));
                    return 0
                ;;
                --component)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -t)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__help)
            opts=" -h -V  --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__install)
            opts=" -h -V -c -t  --no-self-update --force --allow-downgrade --help --version --profile --component --target  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --profile)
                    COMPREPLY=($(compgen -W "minimal default complete" -- "${cur}"));
                    return 0
                ;;
                --component)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -t)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__link)
            opts=" -h -V  --help --version  <toolchain> <path> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__list)
            opts=" -v -h -V  --verbose --help --version  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__remove)
            opts=" -h -V  --help --version  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__uninstall)
            opts=" -h -V  --help --version  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__toolchain__update)
            opts=" -h -V -c -t  --no-self-update --force --allow-downgrade --help --version --profile --component --target  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --profile)
                    COMPREPLY=($(compgen -W "minimal default complete" -- "${cur}"));
                    return 0
                ;;
                --component)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --target)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -t)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__uninstall)
            opts=" -h -V  --help --version  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__update)
            opts=" -h -V  --no-self-update --force --force-non-host --help --version  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__upgrade)
            opts=" -h -V  --no-self-update --force --force-non-host --help --version  <toolchain>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        rustup__which)
            opts=" -h -V  --help --version --toolchain  <command> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in 
                --toolchain)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
    esac
}
_sdk () 
{ 
    local -r previous_word=${COMP_WORDS[COMP_CWORD - 1]};
    local -r current_word=${COMP_WORDS[COMP_CWORD]};
    if ((COMP_CWORD == 3)); then
        local -r before_previous_word=${COMP_WORDS[COMP_CWORD - 2]};
        __sdkman_complete_candidate_version "$before_previous_word" "$previous_word" "$current_word";
        return;
    fi;
    __sdkman_complete_command "$previous_word" "$current_word"
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($(compgen -W '`command sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur"));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local IFS=' 	
' reset=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($(printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions|README)));
    $reset;
    COMPREPLY+=($({ systemctl list-units --full --all ||                      systemctl list-unit-files; } 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }'));
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        COMPREPLY+=($(initctl list 2>/dev/null | cut -d' ' -f1));
    fi;
    COMPREPLY=($(compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur"))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($(compgen -P "$1" -A signal "SIG${cur#$1}"));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    return 0
}
_terms () 
{ 
    COMPREPLY+=($(compgen -W "$({         command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap;
        { toe -a || toe; } | awk '{ print $1 }';
        find /{etc,lib,usr/lib,usr/share}/terminfo/? -type f -maxdepth 1             | awk -F/ '{ print $NF }';
    } 2>/dev/null)" -- "$cur"))
}
_test_names () 
{ 
    _get_names_from_array "test"
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($(compgen -P '~' -u -- "${1#\~}"));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_toolchains () 
{ 
    local result=();
    local toolchains=$(rustup toolchain list);
    local channels="nightly|beta|stable|[0-9]\.[0-9]{1,2}\.[0-9]";
    local date="[0-9]{4}-[0-9]{2}-[0-9]{2}";
    while read line; do
        line=${line%% *};
        if [[ "$line" =~ ^($channels)(-($date))?(-.*) ]]; then
            if [[ -z ${BASH_REMATCH[3]} ]]; then
                result+=("+${BASH_REMATCH[1]}");
            else
                result+=("+${BASH_REMATCH[1]}-${BASH_REMATCH[3]}");
            fi;
            result+=("+$line");
        else
            result+=("+$line");
        fi;
    done <<< "$toolchains";
    echo "${result[@]}"
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent passwd | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/passwd)' -- "$cur"));
        fi;
    fi
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _upvars instead" 1>&2;
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lsusb | awk '{print $6}')" -- "$cur"))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($(compgen -u -S @ -- "$cur"));
        compopt -o nospace;
    fi
}
_usergroup () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($(compgen -g -- "$mycur"));
            fi;
            COMPREPLY=($(compgen -P "$prefix" -W "${COMPREPLY[@]}"));
        else
            if [[ $cur == *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -g -- "$mycur"));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -u -- "$cur"));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == \${* ]]; then
            local arrs vars;
            vars=($(compgen -A variable -P ${BASH_REMATCH[1]} -S '}' -- ${BASH_REMATCH[3]})) && arrs=($(compgen -A arrayvar -P ${BASH_REMATCH[1]} -S '[' -- ${BASH_REMATCH[3]}));
            if [[ ${#vars[@]} -eq 1 && -n $arrs ]]; then
                compopt -o nospace;
                COMPREPLY+=(${arrs[*]});
            else
                COMPREPLY+=(${vars[*]});
            fi;
        else
            COMPREPLY+=($(compgen -A variable -P '$' -- "${BASH_REMATCH[3]}"));
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local IFS='
';
            COMPREPLY+=($(compgen -W '$(printf %s\\n "${!'${BASH_REMATCH[2]}'[@]}")'             -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}' -- "${BASH_REMATCH[3]}"));
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                COMPREPLY+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            __ltrim_colon_completions "$cur";
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                COMPREPLY+=("$cur}");
                __ltrim_colon_completions "$cur";
                return 0;
            else
                case $prev in 
                    TZ)
                        cur=/usr/share/zoneinfo/$cur;
                        _filedir;
                        for i in "${!COMPREPLY[@]}";
                        do
                            if [[ ${COMPREPLY[i]} == *.tab ]]; then
                                unset 'COMPREPLY[i]';
                                continue;
                            else
                                if [[ -d ${COMPREPLY[i]} ]]; then
                                    COMPREPLY[i]+=/;
                                    compopt -o nospace;
                                fi;
                            fi;
                            COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                        done;
                        return 0
                    ;;
                    TERM)
                        _terms;
                        return 0
                    ;;
                    LANG | LC_*)
                        COMPREPLY=($(compgen -W '$(locale -a 2>/dev/null)'                     -- "$cur" ));
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        __load_completion "$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local IFS=' 	
' reset=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($(printf '%s\n' $xinetddir/!($_backup_glob)));
        $reset;
        COMPREPLY+=($(compgen -W '${svcs[@]#$xinetddir/}' -- "$cur"));
    fi
}
catimg () 
{ 
    if command -v convert > /dev/null; then
        zsh /home/carlc/.oh-my-zsh/plugins/catimg/catimg.sh "$@";
    else
        echo "catimg need convert (ImageMagick) to work";
    fi
}
cdfile () 
{ 
    if [[ $# -eq 0 ]]; then
        echo "$0 Error: Write an argument to cd to that file" 2>&1;
    else
        cd $(dirname "$(which "$@")") || { 
            echo "Did not work" && return 1
        };
    fi
}
chromaless () 
{ 
    cat "$1" | chroma | less
}
chtshBash () 
{ 
    if ! command -v curl > /dev/null; then
        echo "curl executable not found" 1>&2 && return 1;
    fi;
    if [ "$#" -eq 0 ]; then
        echo "Usage: chtsh term_to_lookup";
        return 1;
    else
        if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
            echo "Usage: chtsh term_to_lookup";
            return 1;
        else
            echo "Looking up $* on cht.sh";
            command -v curl > /dev/null && command curl "https://cht.sh/$*";
            return 0;
        fi;
    fi
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/lib/command-not-found -- "$1";
        return $?;
    else
        if [ -x /usr/share/command-not-found/command-not-found ]; then
            /usr/share/command-not-found/command-not-found -- "$1";
            return $?;
        else
            printf "%s: command not found\n" "$1" 1>&2;
            return 127;
        fi;
    fi
}
conda () 
{ 
    \local cmd="${1-__missing__}";
    case "$cmd" in 
        activate | deactivate)
            __conda_activate "$@"
        ;;
        install | update | upgrade | remove | uninstall)
            __conda_exe "$@" || \return;
            __conda_reactivate
        ;;
        *)
            __conda_exe "$@"
        ;;
    esac
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
die () 
{ 
    printf '%s\n' "$*" 1>&2 && return 1
}
duks () 
{ 
    local usage="Usage: duks [-h|--help] search_term
    Description: duks will look up the \"search_term\" at duckduckgo.com in a browser window.";
    if [[ $# -eq 0 ]] || [[ "${1}" =~ ^(-h|--help)$ ]]; then
        echo "need args to this func" 1>&2;
        echo "$usage" 2>&1;
        return 1;
    fi;
    if command -v wslview > /dev/null; then
        [[ $# -eq 1 ]] && { 
            echo "Looking up ${1}";
            wslview "https://duckduckgo.com/?q=$1";
            return 0
        };
    else
        echo "wslview executable not found" 2>&1 && return 1;
    fi
}
empty_trash () 
{ 
    if [[ $# -eq 0 ]]; then
        rm -iv ~/.trash/*;
        return 0;
    fi;
    if [[ "$1" == "-f" ]]; then
        rm -f ~/.trash/*;
    fi;
    return 0
}
fzf-file-widget () 
{ 
    local selected="$(__fzf_select__)";
    READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$selected${READLINE_LINE:$READLINE_POINT}";
    READLINE_POINT=$(( READLINE_POINT + ${#selected} ))
}
gawklibpath_append () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
}
gawklibpath_default () 
{ 
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
}
gawklibpath_prepend () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
}
gawkpath_append () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
}
gawkpath_default () 
{ 
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
}
gawkpath_prepend () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"
}
ghrestapi () 
{ 
    if [ $# -eq 0 ]; then
        echo "ghrestapi needs args";
        return 1;
    else
        if command -v curl > /dev/null; then
            curl "https://api.github.com/repos/$1/$2";
            return 0;
        else
            echo "Curl not install in PATH";
        fi;
    fi
}
gitaddandcommit () 
{ 
    if [ "$#" -eq 0 ]; then
        git add . && git commit;
    else
        git add . && git commit -m "$*";
    fi;
    return 0
}
groffman () 
{ 
    if [[ $# -eq 0 ]] || [[ "${1}" =~ ^(-h|--help)$ ]]; then
        echo "Usage: groffman manpage.1";
    else
        command groff -man -T utf8 "$*";
    fi;
    return 0
}
hexConvert () 
{ 
    echo "$*" | hd || return 1;
    return 0
}
infer_platform () 
{ 
    local kernel;
    local machine;
    kernel="$(uname -s)";
    machine="$(uname -m)";
    case $kernel in 
        Linux)
            case $machine in 
                i686)
                    echo "LinuxX32"
                ;;
                x86_64)
                    echo "LinuxX64"
                ;;
                armv6l)
                    echo "LinuxARM32HF"
                ;;
                armv7l)
                    echo "LinuxARM32HF"
                ;;
                armv8l)
                    echo "LinuxARM32HF"
                ;;
                aarch64)
                    echo "LinuxARM64"
                ;;
                *)
                    echo "Exotic"
                ;;
            esac
        ;;
        Darwin)
            case $machine in 
                x86_64)
                    echo "DarwinX64"
                ;;
                arm64)
                    if [[ "$sdkman_rosetta2_compatible" == 'true' ]]; then
                        echo "DarwinX64";
                    else
                        echo "DarwinARM64";
                    fi
                ;;
                *)
                    echo "DarwinX64"
                ;;
            esac
        ;;
        *)
            echo "$kernel"
        ;;
    esac
}
list_my_funcs () 
{ 
    echo "------------ List of commands ------------";
    for comm in "${myCommands[@]}";
    do
        echo "$comm";
    done;
    echo "------------ End of commands ------------";
    echo "Type \`type <command_name>\` for more information.";
    echo "These are commands located in ~/.shell_functions"
}
list_trash () 
{ 
    if [ -d ~/.trash ]; then
        echo -e "=== Listing trash ===\n" 1>&2;
        ls --color=auto --color=auto ~/.trash;
    else
        echo "Trash not found" 1>&2;
    fi
}
nodeprocessconf () 
{ 
    if [[ -x $(which node) ]]; then
        node -p "process.config";
    else
        echo "node executable not found";
    fi
}
nvimconfig () 
{ 
    local NVIMCONFIGDIR=~/.config/nvim/;
    if [[ -d "$NVIMCONFIGDIR" ]]; then
        nvim $NVIMCONFIGDIR;
        return 0;
    else
        echo "$NVIMCONFIGDIR not found buddy" 1>&2;
        return 1;
    fi
}
pwshInvoke () 
{ 
    local usage="Usage: pwshInvoke \"command\"";
    if [ "$#" -eq 0 ]; then
        die "$usage";
    else
        if command -v pwsh.exe > /dev/null; then
            command pwsh.exe -nop -c "$@";
        else
            echo "Powershell executable not found" 1>&2 && return 1;
        fi;
    fi;
    return 0
}
pygcat () 
{ 
    pygmentize <("$1") | less
}
pyhelp () 
{ 
    local usage="This is a simple pydoc-like function to get python documentation.";
    if [[ "$#" -eq 0 ]]; then
        echo "Usage: pyhelp term";
        printf '%s\n' "$usage";
        return 1;
    fi;
    if [[ "$#" -eq 1 ]]; then
        if command -v python3 > /dev/null; then
            python3 -c "import ${1}; help($1)";
        else
            echo "python not detected" 2>&1;
            return 1;
        fi;
    else
        echo "Too many args" 2>&1 && return 1;
    fi
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
rbenv () 
{ 
    local command;
    command="${1:-}";
    if [ "$#" -gt 0 ]; then
        shift;
    fi;
    case "$command" in 
        rehash | shell)
            eval "$(rbenv "sh-$command" "$@")"
        ;;
        *)
            command rbenv "$command" "$@"
        ;;
    esac
}
readmeDir () 
{ 
    local pagecommand=bat.exe;
    local myreadme="$*/README.md";
    if [ -f "$myreadme" ]; then
        echo "Opening $myreadme";
        eval $pagecommand "$myreadme";
    else
        echo "README.md not found in that directory.";
    fi;
    return 0
}
sdk () 
{ 
    COMMAND="$1";
    QUALIFIER="$2";
    case "$COMMAND" in 
        l)
            COMMAND="list"
        ;;
        ls)
            COMMAND="list"
        ;;
        v)
            COMMAND="version"
        ;;
        u)
            COMMAND="use"
        ;;
        i)
            COMMAND="install"
        ;;
        rm)
            COMMAND="uninstall"
        ;;
        c)
            COMMAND="current"
        ;;
        ug)
            COMMAND="upgrade"
        ;;
        d)
            COMMAND="default"
        ;;
        b)
            COMMAND="broadcast"
        ;;
        h)
            COMMAND="home"
        ;;
        e)
            COMMAND="env"
        ;;
    esac;
    if [[ "$COMMAND" == "home" ]]; then
        __sdk_home "$QUALIFIER" "$3";
        return $?;
    fi;
    if [[ "$COMMAND" == "completion" ]]; then
        return 0;
    fi;
    if [[ "$COMMAND" != "update" ]]; then
        ___sdkman_check_candidates_cache "$SDKMAN_CANDIDATES_CACHE" || return 1;
    fi;
    ___sdkman_check_version_cache;
    SDKMAN_AVAILABLE="true";
    if [ -z "$SDKMAN_OFFLINE_MODE" ]; then
        SDKMAN_OFFLINE_MODE="false";
    fi;
    __sdkman_update_broadcast_and_service_availability;
    if [ -f "${SDKMAN_DIR}/etc/config" ]; then
        source "${SDKMAN_DIR}/etc/config";
    fi;
    if [[ -z "$COMMAND" ]]; then
        __sdk_help;
        return 1;
    fi;
    CMD_FOUND="";
    if [[ "$COMMAND" != "selfupdate" || "$sdkman_selfupdate_feature" == "true" ]]; then
        CMD_TARGET="${SDKMAN_DIR}/src/sdkman-${COMMAND}.sh";
        if [[ -f "$CMD_TARGET" ]]; then
            CMD_FOUND="$CMD_TARGET";
        fi;
    fi;
    CMD_TARGET="${SDKMAN_DIR}/ext/sdkman-${COMMAND}.sh";
    if [[ -f "$CMD_TARGET" ]]; then
        CMD_FOUND="$CMD_TARGET";
    fi;
    if [[ -z "$CMD_FOUND" ]]; then
        echo "";
        __sdkman_echo_red "Invalid command: $COMMAND";
        echo "";
        __sdk_help;
    fi;
    local sdkman_valid_candidate=$(echo ${SDKMAN_CANDIDATES[@]} | grep -w "$QUALIFIER");
    if [[ -n "$QUALIFIER" && "$COMMAND" != "help" && "$COMMAND" != "offline" && "$COMMAND" != "flush" && "$COMMAND" != "selfupdate" && "$COMMAND" != "env" && "$COMMAND" != "completion" && "$COMMAND" != "edit" && -z "$sdkman_valid_candidate" ]]; then
        echo "";
        __sdkman_echo_red "Stop! $QUALIFIER is not a valid candidate.";
        return 1;
    fi;
    if [[ "$COMMAND" == "offline" && -n "$QUALIFIER" && -z $(echo "enable disable" | grep -w "$QUALIFIER") ]]; then
        echo "";
        __sdkman_echo_red "Stop! $QUALIFIER is not a valid offline mode.";
    fi;
    local final_rc=0;
    local native_command="${SDKMAN_DIR}/libexec/${COMMAND}";
    local converted_command_name=$(echo "$COMMAND" | tr '-' '_');
    if [ -f "$native_command" ]; then
        if [ -z "$QUALIFIER" ]; then
            "$native_command";
        else
            if [ -z "$3" ]; then
                "$native_command" "$QUALIFIER";
            else
                if [ -z "$4" ]; then
                    "$native_command" "$QUALIFIER" "$3";
                else
                    "$native_command" "$QUALIFIER" "$3" "$4";
                fi;
            fi;
        fi;
        final_rc=$?;
    else
        if [ -n "$CMD_FOUND" ]; then
            __sdk_"$converted_command_name" "$QUALIFIER" "$3" "$4";
            final_rc=$?;
        fi;
    fi;
    if [[ "$COMMAND" != "selfupdate" && "$sdkman_selfupdate_feature" == "true" && "$sdkman_auto_update" == "true" ]]; then
        __sdkman_auto_update "$SDKMAN_REMOTE_VERSION" "$SDKMAN_VERSION";
    fi;
    return $final_rc
}
sinfo () 
{ 
    if [ $# -eq 0 ]; then
        echo "
sinfo gives scoop info for multiple args
";
        return 1;
    fi;
    if [[ "$1" == "-h" ]]; then
        echo "scoop info for multiple args";
        return 1;
    fi;
    for i in "${@}";
    do
        scoop info "$i";
    done
}
whichfile () 
{ 
    [[ "$#" -eq 0 ]] && { 
        echo "Usage: whichfile command_name" 2>&1 && return 1
    };
    command file "$(which "$1")" || return 1;
    return 0
}
whichless () 
{ 
    if [ $# -eq 0 ]; then
        echo "Usage: whichless program_name";
    else
        less $(which $1);
        return 0;
    fi
}
